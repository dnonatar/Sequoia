<!DOCTYPE html>
<html>

<head>
<script src="//d3js.org/d3.v4.min.js"></script>
<script src='//raw.githack.com/karpathy/tsnejs/master/tsne.js'></script>
<script src="//d3js.org/queue.v1.min.js"></script>
<script src="//ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
<script src="https://unpkg.com/d3-simple-slider"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.11/lodash.js"></script>

<style>
/* tell the SVG path to be a thin blue line without any area fill */
	body {
		font-family: sans-serif;
	}
	path { 
		stroke-width: 1; 
		fill: none; 
	} 
	.line_hover { 
		stroke: #ff0000; 
		stroke-width: 2;
		opacity : 1;
	} 
	.line_click {
		stroke: black; 
		opacity : 0.5;
	}
	.line_brush {
		stroke: black;
		opacity : 0.5;
	} 
	.line_ave {
		stroke: black;
		stroke-width: 2;
		opacity : 1;
	}   
	.axis { 
		shape-rendering: crispEdges; 
	} 
	.x.axis line {
		stroke: lightgrey; 
	} .x.axis 
	.minor { 
		stroke-opacity: .5; 
	} 
	.x.axis path { 
		display: black; 
	} 
	.x.axis text { 
		font-size: 14; 
	} 
	.y.axis line, .y.axis
    path { fill: none; stroke: #000; } .y.axis text { font-size: 14; } .y.axisRight
    text { fill: orange; } .y.axisLeft text { fill: steelblue; } 
	
	.kmer-filter {
        position: absolute;
        top: 70px;
        left: 20px;
		}
	.button {
        position: absolute;
        top: 45px;
        left: 20px;
		}

		.plot_type {
        position: absolute;
        top: 45px;
        left: 300px;
		}

	.choose-folder {
        position: absolute;
        top: 15px;
        left: 20px;
		}
	
	.viewport {
        position: absolute;
        top: 100px;
        left: 15px;
        overflow: auto;
        width: 360px;
        height: 400px;
        background-color: #e8e8e8;
        border: 1px solid #AAAAAA;
        border-radius: 4px;
        box-shadow: inset 1px 1px 6px 2px rgba(0,0,0, .25);
	}

	.viewport_selected_text {
		position: absolute;
		top: 500px;
		left: 15px;
	}

	.viewport_selected {
        position: absolute;
        top: 540px;
        left: 15px;
        overflow: auto;
        width: 360px;
        height: 120px;
        background-color: #e8e8e8;
        border: 1px solid #AAAAAA;
        border-radius: 4px;
        box-shadow: inset 1px 1px 6px 2px rgba(0,0,0, .25);
    }
	
	.tsne_parameters {
		position: absolute;
		top: 300px;
    	left: 930px;
	}

	.redraw_tsne_button {
		position: absolute;
		top: 450px;
    	left: 930px;
	}

	.zoomin_button {
		position: absolute;
		top: 500px;
    	left: 930px;
	}

	.zoomout_button {
		position: absolute;
		top: 500px;
    	left: 1000px;
	}

	.normalize_checkbox {
		position: absolute;
		top: 550px;
    	left: 930px;
	}

	.average_checkbox {
		position: absolute;
		top: 590px;
    	left: 930px;
	}

	.export_button {
		position: absolute;
		top: 630px;
    	left: 930px;
	}

	.tsne {
        position: absolute;
        top: 270px;
        left: 400px;
        
    }
	.raw_signal {
        position: absolute;
        top: 10px;
        left: 400px;
        width: 350px;
        height: 200px;
    }
	div.tooltip {	
		position: absolute;			
		text-align: center;			
		width: 100px;					
		height: 48px;					
		padding: 2px;				
		font: 12px sans-serif;		
		background: lightsteelblue;	
		border: 0px;		
		 	border-radius: 8px;			
		pointer-events: none;			
	}
	.brushed {
        opacity: 1.0;
    }
    .non_brushed {
        opacity: 0.7;
    }
	
					
</style>
</head>

<body>
<div class = "button">
	<form id="sort">
		<div> Sort by
			<input type='radio' id="sort_kmer" name="mode" checked>k-mer</input> 
			<input  type='radio' id="sort_median" name="mode">median</input>
			<input  type='radio' id="sort_max" name="mode">max</input>
	  	</div>
	</form>
</div>

<div class = "plot_type">
	<select id="plot_type">
		<option value="box" selected="selected">Box Plot</option>
		<option value="violin">Violin Plot</option>
	</select>
</div>

<div class = "kmer-filter">
	<form name="myform" onkeyup="return handleType()">k-mer filtering  
    	<input type="text" id="myVal1" placeholder="Partial or Full k-mer">
	</form>
</div>

<div class = "choose-folder">
	<form name="myform" onSubmit="return handleFolder()">
		<input name="Submit"  type="submit" value="Choose" >
    	<input type="text" id="folder" placeholder="Type Input Folder">
	</form>
</div>

<div class = "viewport"></div>
<div class = "viewport_selected_text">
	<p><b>Selected k-mers (up to 4)</b></p>
</div>
<div class = "viewport_selected"></div>
<div class = "tsne"></div>
<div class = "raw_signal"></div>

<div class="tsne_parameters"> 
	<div id="slider-parameters"></div>
</div>

<div class = "redraw_tsne_button">
	<button onclick = "redraw_tsne()"> Redraw t-SNE </button>
</div>

<div class = "zoomin_button">
	<button onclick = "zoom_in()"> Zoom in </button>
</div>

<div class = "zoomout_button">
	<button onclick = "zoom_out()"> Zoom out </button>
</div>

<div class = "export_button">
	<button onclick="download_csv()">Download CSV</button> (export selected points)
</div>

<div class = "normalize_checkbox">
	<input type="checkbox" id="normalize_checkbox"> Normalization Mode (click before brush)
</div>

<div class = "average_checkbox">
	<input type="checkbox" id="average_checkbox"> Average Mode (click before brush)
</div>

<script type="text/javascript">
var box_colors = ["rgb(51, 160, 44)","rgb(31, 120, 180)","rgb(18, 38, 26)","rgb(255, 127, 0)"]
var tsne_colors = []
var folder = 'data'
var kmer_number = null

// On landing page, use 'data' as a default folder
d3.csv('data'+'/boxplot_data.csv', function(data) {
	kmer_number = data.length

	// draw the boxplots on landing page
	draw_boxplot(data)
})

// When changing plot type
d3.select(".plot_type").on("change",function(){
	
	var sect = document.getElementById("plot_type");
	var section = sect.options[sect.selectedIndex].value;
	
	if (section == 'violin') {
		draw_violin(filtered_data_violin=[],filtered_data_box=[]);
		draw_clicked_violin(kmer_list, tsne_colors);
	} else {
		draw_boxplot(data=[]);
		draw_clicked_boxplot(kmer_list, tsne_colors)			
	}
})

//when changing sorting option
var dataSort = d3.select("#sort")
dataSort.on("change", function(){
	var sect = document.getElementById("plot_type");
	var section = sect.options[sect.selectedIndex].value;

	if (section == 'violin') {
		draw_violin(filtered_data_violin=[],filtered_data_box=[]);
	} else {
		draw_boxplot(data=[]);			
	}

})

function draw_violin(filtered_data_violin, filtered_data_box) {

	var mySelection = d3.select(".viewport").selectAll("*");
	console.log("selection size: " + mySelection.size());
	mySelection.remove();

	//d3.select(".viewport").selectAll("*").remove()   // not gonna work if placed here. why?
	file1 = './'+folder+'/boxplot_data.csv'
	file2 = './'+folder+'/violin_data.csv'
	queue()
		.defer(d3.csv, file1)
		.defer(d3.csv, file2)
		.await(get_violin)

	function get_violin(error, file1, file2) {
		d3.select(".viewport").selectAll("*").remove()
		box_data = file1
		violin_data = file2
		if (filtered_data_violin.length != 0){ 
			violin_data = filtered_data_violin
			box_data = filtered_data_box
		}
		
		//get sorting option
		var form = document.getElementById("sort")
		var form_val;

		for(var i=0; i<form.length; i++){
		  if(form[i].checked){
		    form_val = form[i].id;}} 

		if (form_val == 'sort_median') {
			violin_data.sort(function(a,b) {
				return b['median'] - a['median'];
			});
			box_data.sort(function(a,b) {
				return b['median'] - a['median'];
			});
		} else if (form_val == 'sort_kmer') {
			violin_data.sort(function(a,b) {
				var x = a['kmer'].toLowerCase();
				var y = b['kmer'].toLowerCase();
				return x < y ? -1 : x > y ? 1 : 0;
			});
			box_data.sort(function(a,b) {
				var x = a['kmer'].toLowerCase();
				var y = b['kmer'].toLowerCase();
				return x < y ? -1 : x > y ? 1 : 0;
			});
		} else if (form_val == 'sort_max') {
			violin_data.sort(function(a,b) {
				return b['max'] - a['max'];
			});
			box_data.sort(function(a,b) {
				return b['max'] - a['max'];
			});
		}
		

		// set the dimensions and margins of the graph
		var margin = {top: 35, right: 20, bottom: 30, left: 60},
		    width = 460 - margin.left - margin.right,
		    height = 8400 - margin.top - margin.bottom;

		// append the svg object to the body of the page
		var svg = d3.select(".viewport")
		  .append("svg")
		    .attr("width", width + margin.left + margin.right)
		    .attr("height", height + margin.top + margin.bottom)
		  .append("g")
		    .attr("transform",
		          "translate(" + margin.left + "," + margin.top + ")");

		// Read the data and compute summary statistics for each 
		
		var kmerValues = violin_data.map(d => d['kmer'])

		// Build and Show the x scale
		var x = d3.scaleLinear()
		  .domain([ 0,2500 ])          
		  .range([0, width])
		svg.append("g")
			.attr("transform", "translate(" + 0 +","+0+ ")")
			.call( d3.axisTop(x) )
		      .selectAll('text')
		        .style("text-anchor", "start")
		        .attr("transform", "translate(12,-7)rotate(-90)");

		// Build and Show the y scale. It is a band scale like for a boxplot: each group has an dedicated RANGE on the axis.
		
		var y = d3.scaleBand()
			.domain(kmerValues)
		    //.range([ 0, height ])
		    .range([ 0, height/kmer_number*box_data.length ])
		    .padding(0.05)     //  it is the space between 2 groups. 0 means no padding. 1 is the maximum.
		  svg.append("g")
		  	 .style("font", "14px times")
		  	 .style("font-weight", "bold")
		    .attr("transform", "translate(" + 0 +","+0+ ")")
		    .call(d3.axisLeft(y))

		  // Features of the histogram
		var histogram = d3.histogram()
		    .domain(x.domain())
		    .thresholds(x.ticks(20))    // Important: how many bins approx are going to be made? It is the 'resolution' of the violin plot
		    .value(d => d)

		// Compute the binning for each group of the dataset
		var sumstat = d3.nest()  // nest function allows to group the calculation per level of a factor
		    .key(function(d) { return d.kmer;})
		    .rollup(function(d) {   // For each key..
		      input = d.map(function(g) { return g.ave_distance;})    // Keep the variable called ave_distance     
		      bins = histogram(input)   // And compute the binning on it.
		      return(bins)
		    })
		    .entries(violin_data)


		// Attach median and max values to sumstat 
		for (i =0; i < box_data.length; i++) {
			sumstat[i]['median'] = box_data[i]['median']
			sumstat[i]['max'] = box_data[i]['max']		
		}
		   
		   

		// What is the biggest number of value in a bin? We need it cause this value will have a width of 100% of the bandwidth.
		var maxNum = 0
		for ( i in sumstat ){
		    allBins = sumstat[i].value
		    lengths = allBins.map(function(a){return a.length;})
		    longest = d3.max(lengths)
		    if (longest > maxNum) { maxNum = longest }
		}

		// The maximum width of a violin must be y.bandwidth = the width dedicated to a group
		var yNum = d3.scaleLinear()
		  	.domain([-maxNum,maxNum])
		    .range([0, y.bandwidth()])
		    

		// Add the shape to this svg!
		violins = svg.selectAll("myViolin")

		    .data(sumstat)
		    .enter()        // So now we are working group per group
		    .append("g")
		      .attr("transform", function(d){ return("translate(0," + y(d.key) +")") } ) // Translation vertically to be at the group position
		    
	    violins.append("path")
	        .datum(function(d){ return(d.value)})     // So now we are working bin per bin
	        .style("stroke", "none")
	        .style("fill","#240acc")
	        .style("opacity",0.5)
	        .attr("d", d3.area()
	            .y0(function(d){ return(yNum(-d.length)) } )
	            .y1(function(d){ return(yNum(d.length)) } )
	            .x(function(d){ return(x(d.x0)) } )
	            .curve(d3.curveCatmullRom)    // This makes the line smoother to give the violin appearance. Try d3.curveStep to see the difference
	            
	        )
	        

	    violins.append('rect')
	        .attr('class', 'cover')
	        .attr('id', function(d){return (d.key +'_violin')})
	        .attr('x', -60)
	        .attr('y', 0)
	        .attr('height', 30)
	        .attr('width', 480)
	        .style('fill', 'white')
	        .style('stroke', 'black')
	        .style('stroke-width', '1px')
			.style('opacity', 0)
			.on("click", function(d) {
				// remove signal plots
					d3.selectAll('.line_click').remove()
					d3.selectAll('.line_hover').remove()
					d3.selectAll('.line_brush').remove()
					data_click = []
					data_hover = []
					data_brush = []
					data_brush_byKmer = {}

				if(kmer_list.length < 4 && kmer_list.includes(d.key)==false) {				
				
					d3.select('#tsne').selectAll('circle').remove()	
					loading_gif()
					
					d3.select(this).style("opacity",0.3)
					d3.select(this).style("stroke",'none')
					d3.select(this).style("fill",box_colors[box_colors.length-1])
					tsne_colors.push(box_colors[box_colors.length-1])	
					box_colors.pop()
					
					// remove selected boxplot from the current viewport
					index = kmerValues.indexOf(d.kmer)
					kmerValues.splice(index, 1)
					/*
					filtered_data = []
					for (i=0;i<data.length;i++) {
						if(kmerValues.includes(data[i]['kmer']) ){
							filtered_data.push(data[i])
						}
					}
					*/

					kmer_list.push(d.key)
					draw_clicked_violin(kmer_list, tsne_colors)
					

					// draw tsne	
					if (kmer_list.length == 1) {
							combine_1_kmer(kmer_list)
					} else if (kmer_list.length == 2) {
							combine_2_kmers(kmer_list)
					} else if (kmer_list.length == 3) {
							combine_3_kmers(kmer_list)
					} else if (kmer_list.length == 4) {
							combine_4_kmers(kmer_list)
					} else{
							d3.select('#tsne').selectAll('circle').remove()
					}
				
				//keep previous color and opacity to be used on mouseout
				previous_color = d3.select(this).style('fill')
				previous_opacity = d3.select(this).style('opacity')
				}
    		})

    		
			.on('mouseover', function(){
				previous_color = d3.select(this).style('fill')
				previous_opacity = d3.select(this).style('opacity')
				d3.select(this)
					.style('fill', 'white')
			        .style('stroke', 'black')
				    .style('stroke-width', 3)
					.style('opacity', 0.4)
			})
			.on('mouseout', function(){
				d3.select(this)
					.style('fill', previous_color)
					.style('opacity', previous_opacity)
					.style('stroke', 'none')
			})

		/*
		d3.select("#sort_median")
			.on("click", function() {
				violins.sort(function(a,b) {
					return d3.descending(Number(a.median),Number(b.median))
				})
				.attr("transform", function(d){ return("translate(0," + y(d.key) +")") } )

				
			})	
		*/

		mybox = d3.select('.viewport').select('svg').select('g')

		mybox.selectAll('circle')
			.data(box_data)
			.enter()
			.append('g')
			.attr('class','violin_median')
			.attr("transform", function(d){ return("translate(0," + y(d.kmer) + ")") } )
			.append('circle')
			.attr('cx', function(d){ return x(d.median)})
			.attr('r', 3)
			.attr('transform', 'translate(' + 0 + ',' + 15 + ')' )
			.style('fill', 'white')
		
		for (i = 0; i<kmer_list.length; i++) {
			d3.select('#'+kmer_list[i]+'_violin').style('fill', tsne_colors[i]) 
			d3.select('#'+kmer_list[i]+'_violin').style('opacity', 0.3) 
			d3.select('#'+kmer_list[i]+'_violin').style('stroke', 'none') 
		}
			
	}
}


function draw_clicked_violin(clicked_kmers, colors) {
	
	d3.select('.viewport_selected').selectAll('*').remove()
	file1 = './'+folder+'/boxplot_data.csv'
	file2 = './'+folder+'/violin_data.csv'
	queue()
		.defer(d3.csv, file1)
		.defer(d3.csv, file2)
		.await(get_violin)

	function get_violin(error, file1, file2) {
		box_data = file1
		violin_data = file2
		
		clicked_violin = []
		clicked_box = []
		
		for (i = 0; i < clicked_kmers.length; i++ ) {
			filtered_datum = violin_data.filter(datum => datum.kmer == clicked_kmers[i])
			clicked_violin =  clicked_violin.concat(filtered_datum)
		}

		for (i = 0; i < clicked_kmers.length; i++ ) { 
			clicked_box.push(box_data.filter(datum => datum.kmer == clicked_kmers[i])[0])
		}
		
		violin_data = clicked_violin
		box_data = clicked_box    // need this to get the median
		kmerValues = clicked_kmers

		// set the dimensions and margins of the graph
		var margin = {top: 10, right: 20, bottom: 30, left: 60},
		    width = 460 - margin.left - margin.right,
		    height = 280 

		// append the svg object to the body of the page
		var svg = d3.select(".viewport_selected")
		  .append("svg")
		    .attr("width", width + margin.left + margin.right)
		    .attr("height", height )
		  .append("g")
		    .attr("transform",
		          "translate(" + margin.left + "," + margin.top + ")");

		// Read the data and compute summary statistics for each species
		
		  var kmerValues = violin_data.map(d => d['kmer'])
		  // Build and Show the x scale
		  var x = d3.scaleLinear()
		    .domain([ 0,2500 ])          
		    .range([0, width])
		  /*  
		  svg.append("g")
		  	.attr("transform", "translate(" + 0 +","+0+ ")")
		  	.call( d3.axisTop(x) )
		        .selectAll('text')
		          .style("text-anchor", "start")
		          .attr("transform", "translate(12,-7)rotate(-90)");
		  */
		  
		  // Build and Show the y scale. It is a band scale like for a boxplot: each group has an dedicated RANGE on the axis. 
		  var y = d3.scaleBand()
		  	.domain(kmerValues)
		    .range([ 0, height/4*clicked_kmers.length ])
		    .padding(0.05)     //  it is the space between 2 groups. 0 means no padding. 1 is the maximum.
		  svg.append("g")
		  	 .style("font", "14px times")
		  	 .style("font-weight", "bold")
		    .attr("transform", "translate(" + 0 +","+0+ ")")
		    .call(d3.axisLeft(y))

		  // Features of the histogram
		  var histogram = d3.histogram()
		        .domain(x.domain())
		        .thresholds(x.ticks(20))    // Important: how many bins approx are going to be made? It is the 'resolution' of the violin plot
		        .value(d => d)

		  // Compute the binning for each group of the dataset
		  var sumstat = d3.nest()  // nest function allows to group the calculation per level of a factor
		    .key(function(d) { return d.kmer;})
		    .rollup(function(d) {   // For each key..
		      input = d.map(function(g) { return g.ave_distance;})    // Keep the variable called ave_distance     
		      bins = histogram(input)   // And compute the binning on it.
		      return(bins)
		    })
		    .entries(violin_data)

		  // What is the biggest number of value in a bin? We need it cause this value will have a width of 100% of the bandwidth.
		  var maxNum = 0
		  for ( i in sumstat ){
		    allBins = sumstat[i].value
		    lengths = allBins.map(function(a){return a.length;})
		    longest = d3.max(lengths)
		    if (longest > maxNum) { maxNum = longest }
		  }

		  // The maximum width of a violin must be y.bandwidth = the width dedicated to a group
		  var yNum = d3.scaleLinear()
		  	.domain([-maxNum,maxNum])
		    .range([0, 60])
		    

		  // Add the shape to this svg!
		  violins = svg.selectAll("myViolin")
		    .data(sumstat)
		    .enter()        // So now we are working group per group
		    .append("g")
		      .attr("transform", function(d){ return("translate(0," + y(d.key) +")") } ) // Translation vertically to be at the group position
		    
		    violins.append("path")
		        .datum(function(d){ return(d.value)})     // So now we are working bin per bin
		        .style("stroke", "none")
		        .style("fill","#240acc")
		        .style("opacity",0.7)
		        .attr("d", d3.area()
		            .y0(function(d){ return(yNum(-d.length)) } )
		            .y1(function(d){ return(yNum(d.length)) } )
		            .x(function(d){ return(x(d.x0)) } )
		            .curve(d3.curveCatmullRom)    // This makes the line smoother to give the violin appearance. 
		            
		        )
		        

		    violins.append('rect')
		        .attr('class', 'cover')
		        .attr('x', -60)
		        .attr('y', 0)
		        .attr('height', 60)
		        .attr('width', 480)
		        .style('fill', function(d,i) {return colors[i]} )
		        .style('stroke', 'none')
		        .style('stroke-width', '1px')
				.style('opacity', 0.5)
				
        		.on("click", function(d) {
        			// remove signal plots
					d3.selectAll('.line_click').remove()
					d3.selectAll('.line_hover').remove()
					d3.selectAll('.line_brush').remove()
					data_click = []
					data_hover = []
					data_brush = []
					data_brush_byKmer = {}

					box_colors.push(d3.select(this).style("fill"))
					tsne_colors.splice(tsne_colors.indexOf(d3.select(this).style("fill")),1)
					index = kmer_list.indexOf(d.key)
					kmer_list.splice(index, 1)
					
					// remove color from the all-kmer panel
					clicked_id = d.key+'_violin'
					d3.select('#'+clicked_id).style('fill','white')
					d3.select('#'+clicked_id).style('opacity',0)
					
					// redraw clicked violin
					draw_clicked_violin(kmer_list, tsne_colors)
					
					// redraw t-SNE
					if (kmer_list.length == 1) {
							combine_1_kmer(kmer_list)
					} else if (kmer_list.length == 2) {
							combine_2_kmers(kmer_list)
					} else if (kmer_list.length == 3) {
							combine_3_kmers(kmer_list)
					} else if (kmer_list.length == 4) {
							combine_4_kmers(kmer_list)
					} else{
							d3.select('#tsne').selectAll('circle').remove()
					}
			
				})
				.on('mouseover', function(d){
					/*
					previous_color = d3.select(this).style('fill')
					previous_opacity = d3.select(this).style('opacity')
					d3.select(this)
						.style('fill', 'white')
				        .style('stroke', 'black')
					    .style('stroke-width', 3)
						.style('opacity', 0.4)
					*/
					
					draw_signal(data_click,data_hover = data_brush_byKmer[d.key] , data_brush)
					
				})

				
				.on('mouseout', function(){
					/*
					d3.select(this)
						.style('fill', previous_color)
						.style('opacity', previous_opacity)
						.style('stroke', 'none')
					*/
					draw_signal(data_click,data_hover = [] , data_brush)
				})
        		
        		/*
				.on('mouseover', function(){
					previous_color = d3.select(this).style('fill')
					previous_opacity = d3.select(this).style('opacity')
					d3.select(this)
						.style('fill', 'grey')
				        .style('stroke', 'none')
						.style('opacity', 0.4)
				})
				.on('mouseout', function(){
					d3.select(this)
						.style('fill', previous_color)
						.style('opacity', previous_opacity)
				})
				*/
			
			
			mybox = d3.select('.viewport_selected').select('svg').select('g')

			mybox.selectAll('circle')
				.data(box_data)
				.enter()
				.append('g')
				.attr('class','violin_median')
				.attr("transform", function(d){ return("translate(0," + y(d.kmer) + ")") } )
				.append('circle')
				.attr('cx', function(d){ return x(d.median)})
				.attr('r', 4)
				.attr('transform', 'translate(' + 0 + ',' + 30 + ')' )
				.style('fill', 'white')
			
			/*
			mybox.selectAll('.violin_median').select('rect')
				.data(box_data)
				.enter()
				.append('g')
				.attr('class','violin_box')
				.attr("transform", function(d){ return("translate(0," + y(d.kmer) + ")") } )
				.append('rect')
				.attr('x', function(d){return x(d.q1)})
				.attr('y', 10)
				.attr('width', function(d) {return (x(d.q3) - x(d.q1)) } )
				.attr('height', 10)
				.style('fill', 'black')
				.style('opacity', 0.3)
			*/	
	
	}
}


// function to be called when a folder is chosen
function handleFolder(event){
	folder = document.getElementById("folder").value
	d3.select(".tsne").selectAll('.circle').remove()
	
	// Draw boxplots on landing page right after choosing a new folder
	d3.csv(folder+'/boxplot_data.csv', function(data) {
		draw_boxplot(data)
	})

	return false;
}

function handleType(event){
	
	text = document.getElementById("myVal1").value
	if (text.length == 0) {
		text = '*****'
	} else if (text.length == 1) {
		text = text + '****'
	} else if (text.length == 2) {
		text = text + '***'
	}	else if (text.length == 3) {
		text = text + '**'
	} else if (text.length == 4) {
		text = text + '*'
	}
	
	
	file1 = './'+folder+'/boxplot_data.csv'
	file2 = './'+folder+'/violin_data.csv'
	queue()
		.defer(d3.csv, file1)
		.defer(d3.csv, file2)
		.await(filter_text)
		
	function filter_text(error, file1, file2){
		data_box = file1
		data_violin = file2
		var kmerValues = data_box.map(d => d['kmer'])
		function matching(kmer) {
			exact1 = kmer[0] == text[0]
			exact2 = kmer[1] == text[1]
			exact3 = kmer[2] == text[2]
			exact4 = kmer[3] == text[3]
			exact5 = kmer[4] == text[4]
			var exact = [exact1,exact2,exact3,exact4,exact5] 
			
			any1 = kmer[0] == 'A' || kmer[0] == 'T' || kmer[0] == 'G' || kmer[0] == 'C' 
			any2 = kmer[1] == 'A' || kmer[1] == 'T' || kmer[1] == 'G' || kmer[1] == 'C' 
			any3 = kmer[2] == 'A' || kmer[2] == 'T' || kmer[2] == 'G' || kmer[2] == 'C' 
			any4 = kmer[3] == 'A' || kmer[3] == 'T' || kmer[3] == 'G' || kmer[3] == 'C' 
			any5 = kmer[4] == 'A' || kmer[4] == 'T' || kmer[4] == 'G' || kmer[4] == 'C' 
			
			var any = [any1,any2,any3,any4,any5]
 
			var conditions = []
			for (i=0;i<5;i++) {
				if (text[i]=='*') {
					conditions.push(any[i])
				} else {
					conditions.push(exact[i])
				}
			}
			return (conditions[0] && conditions[1] && conditions[2] && conditions[3] && conditions[4])
		}
		filtered_kmers = kmerValues.filter(matching)
		
		// get sorting type
		var form = document.getElementById("sort")
		var form_val;
		for(var i=0; i<form.length; i++){
  	  		if(form[i].checked){
  	    		form_val = form[i].id;}
  		}

		var sect = document.getElementById("plot_type");
		var section = sect.options[sect.selectedIndex].value;

		// get filtered data based on filtered_kmers
		
		filtered_data_box = []
		filtered_data_violin = []

		for (i=0;i<data_box.length;i++) {
			if(filtered_kmers.includes(data_box[i]['kmer']) ){
				filtered_data_box.push(data_box[i])
			}
		}	
		
		for (i=0;i<data_violin.length;i++) {
			if(filtered_kmers.includes(data_violin[i]['kmer']) ){
				filtered_data_violin.push(data_violin[i])
			}
		}
					
				
		// remove and redraw 
		
		if (section == 'box') {
			draw_boxplot(filtered_data_box)
		} else if (section == 'violin') {
			draw_violin(filtered_data_violin, filtered_data_box)
		}
	
	}
	
	
	// return false prevents the page from reloading after submitting		
	return false;
}
	
var opt = {} // epsilon is learning rate (10 = default)
opt.epsilon = 100;
opt.perplexity = 10;
var tsne = new tsnejs.tSNE(opt); // create a tSNE instance


// create t-sne axes on landing page
d3.select('.tsne')
	.append('svg')
	.attr("width", 500)
	.attr("height", 400)
	.attr("id", "tsne")

var xScale_tsne = d3.scaleLinear()
				.domain([0,0])	
				//.range([padding,width - padding * 2])	
				.range([40,500-20])
				.nice();

var yScale_tsne = d3.scaleLinear()
		.domain([0,0])
		//.range([height - padding, padding])
		.range([20, 400-40])
		.nice();

var x_axis = d3.axisBottom()
                   .scale(xScale_tsne);  

d3.select("#tsne").append("g")
		.attr("class", "x_axis_tsne")
	 	.attr("transform", "translate(0,360)")
		.call(x_axis);

d3.select("#tsne").append("text")
		.attr("transform", "translate(255,395)")
		.style("text-anchor","middle")
		.text("t-SNE 1")

var y_axis = d3.axisLeft()
           .scale(yScale_tsne);  

d3.select("#tsne").append("g")
		.attr("class", "y_axis_tsne")
	 	.attr("transform", "translate(40,0)")
		.call(y_axis);

d3.select("#tsne").append("text")
		.attr('transform', 'translate(15,190)rotate(-90)')
		.style("text-anchor","middle")
		.text("t-SNE 2")

var x0_tsne;
var y0_tsne;
var brush;
// function for drawing t-sne
function draw_tsne(position, kmer_list, kmer_size) {
	
	var width = 500;
	var height = 400;
	//var padding = 65;
	
	d3.select('#tsne').remove()
	var svg = d3.select('.tsne')
			.append('svg')
			.attr("width", width)
    		.attr("height", height)
			.attr("id", "tsne")		

	//var xScale = d3.scaleLinear()
	x0_tsne = d3.extent(position, function(d) {return d[0]; })
	xScale_tsne.domain(x0_tsne)	
			//.range([padding,width - padding * 2])	
			.range([40,width-20])
			.nice();

	//var yScale = d3.scaleLinear()
	y0_tsne = d3.extent(position, function(d) {return d[1]; })
	yScale_tsne.domain(y0_tsne)
			//.range([height - padding, padding])
			//.range([20, height-40])
			.range([height-40, 20])
			.nice();

	var x_axis = d3.axisBottom()
               .scale(xScale_tsne);  

	svg.append("g")
			.attr("class", "x_axis_tsne")
		 	.attr("transform", "translate(0,360)")
   			.call(x_axis);

	svg.append("text")
			.attr("transform", "translate(255,395)")
			.style("text-anchor","middle")
			.text("t-SNE 1")

	var y_axis = d3.axisLeft()
               .scale(yScale_tsne);  

	svg.append("g")
			.attr("class", "y_axis_tsne")
		 	.attr("transform", "translate(40,0)")
   			.call(y_axis);

	svg.append("text")
			.attr('transform', 'translate(15,190)rotate(-90)')
			.style("text-anchor","middle")
			.text("t-SNE 2")

	brush = d3.brush()
				.on("brush", whileBrush)
				

	d3.select('#tsne').append("g")
			.call(brush)
			.call(brush.move)

	var old_color = null
	var circles = svg.append("g")
			.selectAll('circle')
		  .data(position)
		  .enter()
		  .append('circle')
		  	.attr('r', 6)
			.attr('cx', function(d) {
					return xScale_tsne(d[0]);
			})
			.attr('cy', function(d) {
					return yScale_tsne(d[1]);
			})
			.attr("class", "non_brushed")
			.style('fill', function(d,i) { 
				if (kmer_list.length == 1) {
					return tsne_colors[0];
				
				} else if (kmer_list.length == 2) {	
					if (i < kmer_size[0]) {
						return tsne_colors[0];
					} else {
						return tsne_colors[1];
					}
				} else if (kmer_list.length == 3) {
					if (i < kmer_size[0]) {
						return tsne_colors[0];
					} else if(i >= kmer_size[0] && i < kmer_size[0]+kmer_size[1]) {
						return tsne_colors[1];
					} else {
						return tsne_colors[2];
					}
				} else if (kmer_list.length == 4) {
						if (i < kmer_size[0]) {
						return tsne_colors[0];
					} else if(i >= kmer_size[0] && i < kmer_size[0]+kmer_size[1]) {
						return tsne_colors[1];
					} else if(i >= kmer_size[0]+kmer_size[1] && i < kmer_size[0]+kmer_size[1]+kmer_size[2]) {
						return tsne_colors[2];
					} else {
						return tsne_colors[3];
					}
				}
			})
			
			.on('click',function(d,i){
				if (d3.select(this).style("stroke") == "none") {
					d3.select(this).style("stroke", "black");
					d3.select(this).style("stroke-width", 2);
				}	else {
					d3.select(this).style("stroke", "none");
				}
				
				add_signal(i, kmer_list);
											
			})
			
			
			.on('mouseover', function(d,i){
				old_color = d3.select(this).style("fill")
				d3.select(this).attr("r", "10");
				d3.select(this).style("fill", "#ff0000")
				add_signal_hover(i, kmer_list);
			})
			.on('mouseout', function(d,i){
				d3.select(this).attr("r", "6");
				d3.select(this).style("fill", old_color)
				remove_signal_hover();
			})
			
	
	function highlightBrushedCircles() {
    if (d3.event.selection != null) {
       // revert circles to initial style
       circles.attr("class", "non_brushed");
       var brush_coords = d3.brushSelection(this);
       // style brushed circles
       circles.filter(function (){
       						var cx = d3.select(this).attr("cx"),
                      cy = d3.select(this).attr("cy");
                  return isBrushed(brush_coords, cx, cy);
              })
              .attr("class", "brushed");
				
     }
	}

	var lastBrushEvent = 0;

	
	
	function whileBrush() {
		// disregard brushes w/o selections				
		if (!d3.event.selection) {
			return;
		}
		// programmed clearing of brush after mouse-up
		//d3.select(this).call(brush.move, null);
			
		if (d3.event.selection != null) {
			s = d3.event.selection
			
			// revert circles to initial style
			circles.attr("class", "non_brushed");
			var brush_coords = d3.brushSelection(this);
			
			// style brushed circles
			circles.filter(function (){
				var cx = d3.select(this).attr("cx"),
				cy = d3.select(this).attr("cy");
				return isBrushed(brush_coords, cx, cy);
			})
			.attr("class", "brushed");
		} else {
			console.log("no select brush")
		}

		// get indices for the brushed points
		var d_brushed =  d3.selectAll(".brushed").data();

		var row_list = []				
		if (d_brushed.length > 0 && row_list.length ==0) 
		{
			d_brushed.forEach(d_each => row_list.push(position.indexOf(d_each)))
		}
		
		(function(row_list, kmer_list, brushEvent) {
			setTimeout(function() 
			{
				if (brushEvent == lastBrushEvent) {
					add_signal_brush(row_list, kmer_list)
				}
				else
				{
					console.log("SAVED loading");
				}
			}, 2);

		})(row_list, kmer_list, ++lastBrushEvent)
	}		
}

var s;
var idleTimeout, idleDelay = 350;

function zoom_in() {
	xScale_tsne.domain([s[0][0], s[1][0]].map(xScale_tsne.invert, xScale_tsne));
	yScale_tsne.domain([s[1][1], s[0][1]].map(yScale_tsne.invert, yScale_tsne));
	zoom_tsne()
}

function zoom_out() {
	xScale_tsne.domain(x0_tsne);
	yScale_tsne.domain(y0_tsne);
	zoom_tsne()
}

function zoom_tsne() {
	svg = d3.select('.tsne')
	var t = svg.transition().duration(750);
	svg.select(".x_axis_tsne").transition(t).call(x_axis);
	svg.select(".y_axis_tsne").transition(t).call(y_axis);
	svg.selectAll("circle").transition(t)
	  .attr("cx", function(d) { return xScale_tsne(d[0]); })
	  .attr("cy", function(d) { return yScale_tsne(d[1]); });
}

function isBrushed(brush_coords, cx, cy) {
     var x0 = brush_coords[0][0],
         x1 = brush_coords[1][0],
         y0 = brush_coords[0][1],
         y1 = brush_coords[1][1];
	
      return x0 <= cx && cx <= x1 && y0 <= cy && cy <= y1;
}

// function to sum all arrays in 'data'
function sum_columns(data) {
	return _.map(_.unzip(data), _.sum);
}

// add new signals to data array and then pass it to draw_signal 
var data_click = []
var data_hover = []
var data_row = []
var data_brush = []
var data_export_click = []
var data_export_brush = []
var data_brush_byKmer 
var data_brush_kmer1 = []
var data_brush_kmer2 = []
var data_brush_kmer3 = []
var data_brush_kmer4 = []
var data_ave = []

function add_signal_brush(row_list, kmer_list, currentBrushEvent) {
	data_brush_kmer1.length = 0
	data_brush_kmer2.length = 0
	data_brush_kmer3.length = 0
	data_brush_kmer4.length = 0

	if (kmer_list.length == 1) {
		kmer1 = kmer_list[0]
		filename1 = folder+'/raw_signal/'+kmer1+'_signal.csv';
		
		(function(row_list, filename1, currentBrushEvent) {

			queue()
				.defer(d3.csv, filename1)
				.await(add)
		
			function add(error, file1){
				if (error) { console.log("SAVED loading"); return; }
				d = file1
				
				data_brush.length = 0
				data_export_brush.length = 0

				for (i=0;i<row_list.length;i++){
					row = row_list[i]
					data_brush.push(d[row]['values'].split("_").map(Number))
					data_export_brush.push(d[row])
				}


				draw_signal(data_click, data_hover, data_brush)

				data_brush_byKmer = {}
				data_brush_byKmer[kmer_list[0]] = data_brush

				data_ave1 = sum_columns(data_brush).map(function(x) {return x/data_brush.length})

				data_ave = [data_ave1]
			
			}

		})(row_list, filename1, currentBrushEvent);

	} else if (kmer_list.length == 2) {
		kmer1 = kmer_list[0]
		kmer2 = kmer_list[1]
		filename1 = folder+'/raw_signal/'+kmer1+'_signal.csv';
		filename2 = folder+'/raw_signal/'+kmer2+'_signal.csv';
		queue()
			.defer(d3.csv, filename1)
			.defer(d3.csv, filename2)
			.await(add)
	
		function add(error, file1, file2){
			d = file1.concat(file2)
			
			data_brush.length = 0
			data_export_brush.length = 0

			for (i=0;i<row_list.length;i++){
				row = row_list[i]
				data_brush.push(d[row]['values'].split("_").map(Number))
				data_export_brush.push(d[row])

				if (row < kmer_size[0]){
					data_brush_kmer1.push(d[row]['values'].split("_").map(Number))
				} else {
					data_brush_kmer2.push(d[row]['values'].split("_").map(Number))
				}
			}
			
			data_brush_byKmer = {}
			data_brush_byKmer[kmer_list[0]] = data_brush_kmer1
			data_brush_byKmer[kmer_list[1]] = data_brush_kmer2

			
			data_ave1 = sum_columns(data_brush_kmer1).map(function(x) {return x/data_brush_kmer1.length})
			data_ave2 = sum_columns(data_brush_kmer2).map(function(x) {return x/data_brush_kmer2.length})

			data_ave = [data_ave1, data_ave2]

			draw_signal(data_click, data_hover, data_brush)

		}
	}	else if (kmer_list.length == 3) {
		kmer1 = kmer_list[0]
		kmer2 = kmer_list[1]
		kmer3 = kmer_list[2]
		filename1 = folder+'/raw_signal/'+kmer1+'_signal.csv';
		filename2 = folder+'/raw_signal/'+kmer2+'_signal.csv';
		filename3 = folder+'/raw_signal/'+kmer3+'_signal.csv';
		queue()
			.defer(d3.csv, filename1)
			.defer(d3.csv, filename2)
			.defer(d3.csv, filename3)
			.await(add)
	
		function add(error, file1, file2, file3){
			d = file1.concat(file2).concat(file3)
			
			data_brush.length = 0
			data_export_brush.length = 0
			
			for (i=0;i<row_list.length;i++){
				row = row_list[i]
				data_brush.push(d[row]['values'].split("_").map(Number))
				data_export_brush.push(d[row])

				if (row < kmer_size[0]){
				data_brush_kmer1.push(d[row]['values'].split("_").map(Number))
				} else if (row >= kmer_size[0] && row < kmer_size[0] + kmer_size[1]) {
					data_brush_kmer2.push(d[row]['values'].split("_").map(Number))
				} else {
					data_brush_kmer3.push(d[row]['values'].split("_").map(Number))
				}
			}
			
			data_brush_byKmer = {}
			data_brush_byKmer[kmer_list[0]] = data_brush_kmer1
			data_brush_byKmer[kmer_list[1]] = data_brush_kmer2
			data_brush_byKmer[kmer_list[2]] = data_brush_kmer3

			data_ave1 = sum_columns(data_brush_kmer1).map(function(x) {return x/data_brush_kmer1.length})
			data_ave2 = sum_columns(data_brush_kmer2).map(function(x) {return x/data_brush_kmer2.length})
			data_ave3 = sum_columns(data_brush_kmer3).map(function(x) {return x/data_brush_kmer3.length})

			data_ave = [data_ave1, data_ave2, data_ave3]

			draw_signal(data_click, data_hover, data_brush)
		}
	}	else if (kmer_list.length == 4) {
		kmer1 = kmer_list[0]
		kmer2 = kmer_list[1]
		kmer3 = kmer_list[2]
		kmer4 = kmer_list[3]
		filename1 = folder+'/raw_signal/'+kmer1+'_signal.csv';
		filename2 = folder+'/raw_signal/'+kmer2+'_signal.csv';
		filename3 = folder+'/raw_signal/'+kmer3+'_signal.csv';
		filename4 = folder+'/raw_signal/'+kmer4+'_signal.csv';
		queue()
			.defer(d3.csv, filename1)
			.defer(d3.csv, filename2)
			.defer(d3.csv, filename3)
			.defer(d3.csv, filename4)
			.await(add)
	
		function add(error, file1, file2, file3, file4){
			d = file1.concat(file2).concat(file3).concat(file4)
			
			data_brush.length = 0
			data_export_brush.length = 0
			
			for (i=0;i<row_list.length;i++){
				row = row_list[i]
				data_brush.push(d[row]['values'].split("_").map(Number))
				data_export_brush.push(d[row])

				if (row < kmer_size[0]){
					data_brush_kmer1.push(d[row]['values'].split("_").map(Number))
				} else if (row >= kmer_size[0] && row < kmer_size[0] + kmer_size[1]) {
					data_brush_kmer2.push(d[row]['values'].split("_").map(Number))
				} else if (row >= kmer_size[0]+kmer_size[1] && row < kmer_size[0]+kmer_size[1]+kmer_size[2]){
					data_brush_kmer3.push(d[row]['values'].split("_").map(Number))
				} else {
					data_brush_kmer4.push(d[row]['values'].split("_").map(Number))
				}
			}

			data_brush_byKmer = {}
			data_brush_byKmer[kmer_list[0]] = data_brush_kmer1
			data_brush_byKmer[kmer_list[1]] = data_brush_kmer2
			data_brush_byKmer[kmer_list[2]] = data_brush_kmer3
			data_brush_byKmer[kmer_list[3]] = data_brush_kmer4
			
			data_ave1 = sum_columns(data_brush_kmer1).map(function(x) {return x/data_brush_kmer1.length})
			data_ave2 = sum_columns(data_brush_kmer2).map(function(x) {return x/data_brush_kmer2.length})
			data_ave3 = sum_columns(data_brush_kmer3).map(function(x) {return x/data_brush_kmer3.length})
			data_ave4 = sum_columns(data_brush_kmer4).map(function(x) {return x/data_brush_kmer4.length})

			data_ave = [data_ave1, data_ave2, data_ave3, data_ave4]
			draw_signal(data_click, data_hover, data_brush)
		}
	}

}


function add_signal(row, kmer_list){
	if (kmer_list.length == 1) {
		kmer1 = kmer_list[0]
		filename1 = folder+'/raw_signal/'+kmer1+'_signal.csv';
		queue()
			.defer(d3.csv, filename1)
			.await(add)
		function add(error, file1){
				d = file1
				if (data_row.includes(row)) {
						index = data_row.indexOf(row)
						data_row.splice(index, 1)
						data_click.splice(index, 1)
						data_export_click.splice(index,1)
				} else {
						data_row.push(row)
						data_click.push(d[row]['values'].split("_").map(Number))
						data_export_click.push(d[row])		
				}
				
				draw_signal(data_click, data_hover, data_brush)
		}
	} else if (kmer_list.length == 2) {
		kmer1 = kmer_list[0]
		kmer2 = kmer_list[1]
		filename1 = folder+'/raw_signal/'+kmer1+'_signal.csv';
		filename2 = folder+'/raw_signal/'+kmer2+'_signal.csv';
		queue()
			.defer(d3.csv, filename1)
			.defer(d3.csv, filename2)
			.await(add)
		function add(error, file1, file2){
				d = file1.concat(file2)
				if (data_row.includes(row)) {
						index = data_row.indexOf(row)
						data_row.splice(index, 1)
						data_click.splice(index, 1)
						data_export_click.splice(index,1)
	
				} else {
						data_row.push(row)
						data_click.push(d[row]['values'].split("_").map(Number))		
						data_export_click.push(d[row])
				}
				
				draw_signal(data_click, data_hover, data_brush)
		}
	} else if (kmer_list.length == 3) {
		kmer1 = kmer_list[0]
		kmer2 = kmer_list[1]
		kmer3 = kmer_list[2]
		filename1 = folder+'/raw_signal/'+kmer1+'_signal.csv';
		filename2 = folder+'/raw_signal/'+kmer2+'_signal.csv';
		filename3 = folder+'/raw_signal/'+kmer3+'_signal.csv';
		queue()
			.defer(d3.csv, filename1)
			.defer(d3.csv, filename2)
			.defer(d3.csv, filename3)
			.await(add)
		function add(error, file1, file2, file3){
				d = file1.concat(file2).concat(file3)
				if (data_row.includes(row)) {
						index = data_row.indexOf(row)
						data_row.splice(index, 1)
						data_click.splice(index, 1)
						data_export_click.splice(index,1)
				} else {
						data_row.push(row)
						data_click.push(d[row]['values'].split("_").map(Number))		
						data_export_click.push(d[row])
				}
				
				draw_signal(data_click, data_hover, data_brush)
		}
	} else if (kmer_list.length == 4) {
		kmer1 = kmer_list[0]
		kmer2 = kmer_list[1]
		kmer3 = kmer_list[2]
		kmer4 = kmer_list[3]
		filename1 = folder+'/raw_signal/'+kmer1+'_signal.csv';
		filename2 = folder+'/raw_signal/'+kmer2+'_signal.csv';
		filename3 = folder+'/raw_signal/'+kmer3+'_signal.csv';
		filename4 = folder+'/raw_signal/'+kmer4+'_signal.csv';
		queue()
			.defer(d3.csv, filename1)
			.defer(d3.csv, filename2)
			.defer(d3.csv, filename3)
			.defer(d3.csv, filename4)
			.await(add)
		function add(error, file1, file2, file3, file4){
				d = file1.concat(file2).concat(file3).concat(file4)
				if (data_row.includes(row)) {
						index = data_row.indexOf(row)
						data_row.splice(index, 1)
						data_click.splice(index, 1)
						data_export_click.splice(index,1)
				} else {
						data_row.push(row)
						data_click.push(d[row]['values'].split("_").map(Number))
						data_export_click.push(d[row])		
				}
				
				draw_signal(data_click, data_hover, data_brush)
		}
	}
	
}
var signalToAdd = null;
function add_signal_hover(row, kmer_list){
	if (kmer_list.length == 1) {
		kmer1 = kmer_list[0]
		filename1 = folder+'/raw_signal/'+kmer1+'_signal.csv';
		queue()	
			.defer(d3.csv, filename1)
			.await(add)
		current_kmer = kmer1
		signalToAdd = current_kmer + '_' + row;
		function add(error, file1){
			d = file1
			d3.selectAll('.line_hover').remove();
			if (signalToAdd == current_kmer + '_' + row)
			{
				data_hover.push(d[row]['values'].split("_").map(Number))
				draw_signal(data_click, data_hover, data_brush)
				
			}
	
		}
	}	else if (kmer_list.length == 2) {
		kmer1 = kmer_list[0]
		kmer2 = kmer_list[1]
		filename1 = folder+'/raw_signal/'+kmer1+'_signal.csv';
		filename2 = folder+'/raw_signal/'+kmer2+'_signal.csv';
		queue()	
			.defer(d3.csv, filename1)
			.defer(d3.csv, filename2)
			.await(add)
		current_kmer = kmer1+'_'+kmer2
		signalToAdd = current_kmer + '_' + row;
		function add(error, file1, file2){
			d = file1.concat(file2)
			d3.selectAll('.line_hover').remove();
			if (signalToAdd == current_kmer + '_' + row)
			{
				data_hover.push(d[row]['values'].split("_").map(Number))
				draw_signal(data_click, data_hover, data_brush)
			}
		}
	} else if (kmer_list.length == 3) {
		kmer1 = kmer_list[0]
		kmer2 = kmer_list[1]
		kmer3 = kmer_list[2]
		filename1 = folder+'/raw_signal/'+kmer1+'_signal.csv';
		filename2 = folder+'/raw_signal/'+kmer2+'_signal.csv';
		filename3 = folder+'/raw_signal/'+kmer3+'_signal.csv';
		queue()	
			.defer(d3.csv, filename1)
			.defer(d3.csv, filename2)
			.defer(d3.csv, filename3)
			.await(add)
		current_kmer = kmer1+'_'+kmer2+'_'+kmer3
		signalToAdd = current_kmer + '_' + row;
		function add(error, file1, file2, file3){
			d = file1.concat(file2).concat(file3)
			d3.selectAll('.line_hover').remove();
			if (signalToAdd == current_kmer + '_' + row)
			{
				data_hover.push(d[row]['values'].split("_").map(Number))
				draw_signal(data_click, data_hover, data_brush)
			}
		}
	} else if (kmer_list.length == 4) {
		kmer1 = kmer_list[0]
		kmer2 = kmer_list[1]
		kmer3 = kmer_list[2]
		kmer4 = kmer_list[3]
		
		filename1 = folder+'/raw_signal/'+kmer1+'_signal.csv';
		filename2 = folder+'/raw_signal/'+kmer2+'_signal.csv';
		filename3 = folder+'/raw_signal/'+kmer3+'_signal.csv';
		filename4 = folder+'/raw_signal/'+kmer4+'_signal.csv';
		queue()	
			.defer(d3.csv, filename1)
			.defer(d3.csv, filename2)
			.defer(d3.csv, filename3)
			.defer(d3.csv, filename4)
			.await(add)
		current_kmer = kmer1+'_'+kmer2+'_'+kmer3+'_'+kmer4
		signalToAdd = current_kmer + '_' + row;
		function add(error, file1, file2, file3, file4){
			d = file1.concat(file2).concat(file3).concat(file4)
			d3.selectAll('.line_hover').remove();
			if (signalToAdd == current_kmer + '_' + row)
			{
				data_hover.push(d[row]['values'].split("_").map(Number))
				draw_signal(data_click, data_hover, data_brush)
			}
		}
	}
}

function remove_signal_hover(){
	
	data_hover = []
	d3.selectAll('.line_hover').remove();
	signalToAdd=null;
}

var div = d3.select("body").append("div")	
    .attr("class", "tooltip")				
    .style("opacity", 0);

box_colors = ["rgb(51, 160, 44)","rgb(31, 120, 180)","rgb(18, 38, 26)","rgb(255, 127, 0)"]  //reset when changing sort type

kmer_list = []
function draw_boxplot(passed_data) {
	file1 = './'+folder+'/boxplot_data.csv'
	queue()
		.defer(d3.csv, file1)
		.await(get_box)

	function get_box(error, file1) {
		d3.select(".viewport").selectAll("*").remove()

		data = file1
		
		if (passed_data.length != 0){ 
			data = passed_data
		}
		
		// get sorting option
		var form = document.getElementById("sort")
		var form_val;
		for(var i=0; i<form.length; i++){
		  if(form[i].checked){
		    form_val = form[i].id;}} 

		if (form_val == 'sort_median') {
			data.sort(function(a,b) {
				return b['median'] - a['median'];
			});
		} else if (form_val == 'sort_kmer') {
			data.sort(function(a,b) {
				var x = a['kmer'].toLowerCase();
				var y = b['kmer'].toLowerCase();
				return x < y ? -1 : x > y ? 1 : 0;
			});
		} else if (form_val == 'sort_max') {
			data.sort(function(a,b) {
				return b['max'] - a['max'];
			});
		}
		

		var w = 580
		var h = 7500*data.length /kmer_number
		var margin = {
		    top: 40,
		    bottom: 20,
		    left: 20,
		    right: 30
	  	}
	  	
		d3.select('.viewport')
	    	.append('svg')
			    .attr('height', h)
			    .attr('width', w)
			    //.attr("transform","translate(" + margin.left + "," + margin.top + ")");


		var catVariable = 'order'
		var catValues = data.map(d => Number(d[catVariable]))
		var kmerValues = data.map(d => d['kmer'])
		const minVariable = 'min'
	    const maxVariable = 'max'
	    const medianVariable = 'median'
	    const q1Variable = 'q1'
	    const q3Variable = 'q3'

		var xScale = d3.scaleLinear()
			.domain([0,8000])
			.range([margin.left, w- margin.right-50])
		/*
		var x = d3.scaleLinear()
			  .domain([ 0,2500 ])          
			  .range([0, width])
		*/
			
		var xAxis = d3.axisTop() 
						.scale(xScale)
			      		.tickSize(5)

		var yScale = d3.scalePoint()
				.domain(kmerValues)
				.range([margin.top,h - margin.bottom])
		
		var yAxis = d3.axisRight()
						.scale(yScale)
						.tickSize(0)

					//.tickValues(catValues)
						//.tickValues(kmerValues)
		
		d3.select('svg')
			.append('g')
				.style("font", "14px times")
				.attr('transform', 'translate(40,20)')
				.attr('id', 'xAxisG')
				.call(xAxis)

		d3.select('svg')
			.append('g')
				.style("font", "14px times")
				.style("font-weight", "bold")
				.attr('transform', 'translate(0,0)')
				.attr('id', 'yAxisG')
				.call(yAxis)

		var previous_color = null
	    var previous_opacity = null

		d3.select('svg')
			.selectAll('g.box')
			.data(data)
			.enter()		
			.append('g')
			.attr('class', 'box')
			.attr(
				'transform', d => `translate(${xScale(d[medianVariable])+40},${yScale(d['kmer'])})`
			)
			
			.each(function(d, i) {
				d3.select(this)
			        .append('rect')
			        .attr('class', 'cover')
			        .attr('id', d['kmer']+'_box')
			        .attr('x', -150)
			        .attr('y', -10)
			        .attr('height', 20)
			        .attr('width', 800)
			        .style('fill', 'white')
			        .style('stroke', 'black')
			        .style('stroke-width', '1px')
					.style('opacity', 0)
					.on("click", function(d) {
						// remove signal plots
						d3.selectAll('.line_click').remove()
						d3.selectAll('.line_hover').remove()
						d3.selectAll('.line_brush').remove()
						data_click = []
						data_hover = []
						data_brush = []
						data_brush_byKmer = {}

						if(kmer_list.length < 4 && kmer_list.includes(d.kmer)==false) {				
						
							d3.select('#tsne').selectAll('circle').remove()	
							loading_gif()
							
							d3.select(this).style("opacity",0.3)
							d3.select(this).style("stroke",'none')
							d3.select(this).style("fill",box_colors[box_colors.length-1])
							tsne_colors.push(box_colors[box_colors.length-1])	
							box_colors.pop()
							
							// remove selected boxplot from the current viewport
							index = kmerValues.indexOf(d.kmer)
							kmerValues.splice(index, 1)
							/*
							filtered_data = []
							for (i=0;i<data.length;i++) {
								if(kmerValues.includes(data[i]['kmer']) ){
									filtered_data.push(data[i])
								}
							}
							*/

							// get sorting option
							var form = document.getElementById("sort")
							var form_val;
							for(var i=0; i<form.length; i++){
		      	  				if(form[i].checked){
		      	    				form_val = form[i].id;
								}
							}

							
							kmer_list.push(d.kmer)
													
							draw_clicked_boxplot(kmer_list, tsne_colors)
								
							if (kmer_list.length == 1) {
									combine_1_kmer(kmer_list)
							} else if (kmer_list.length == 2) {
									combine_2_kmers(kmer_list)
							} else if (kmer_list.length == 3) {
									combine_3_kmers(kmer_list)
							} else if (kmer_list.length == 4) {
									combine_4_kmers(kmer_list)
							} else{
									d3.select('#tsne').selectAll('circle').remove()
							}
						
						previous_color = d3.select(this).style('fill')
						previous_opacity = d3.select(this).style('opacity')
						}

					})

	        		
					.on('mouseover', function(){
						previous_color = d3.select(this).style('fill')
						previous_opacity = d3.select(this).style('opacity')
						d3.select(this)
							.style('fill', 'white')
					        .style('stroke', 'black')
					        .style('stroke-width', 3)
							.style('opacity', 0.4)
					})
					.on('mouseout', function(){
						d3.select(this)
							.style('fill', previous_color)
							.style('opacity', previous_opacity)
							.style('stroke', 'none')
					        
					})

				d3.select(this)
					.append('line')
						.attr('class', 'range')
						.attr('x1', xScale(d[maxVariable]) - xScale(d[medianVariable]))
				        .attr('x2', xScale(d[minVariable]) - xScale(d[medianVariable]))
				        .attr('y1', 0)
				        .attr('y2', 0)
				        .style('stroke', 'black')
				        .style('stroke-width', '2px')
				d3.select(this)
			        .append('line')
				        .attr('class', 'max')
				        .attr('x1', xScale(d[maxVariable]) - xScale(d[medianVariable]))
				        .attr('x2', xScale(d[maxVariable]) - xScale(d[medianVariable]))
				        .attr('y1', -8)
				        .attr('y2', 8)
				        .style('stroke', 'black')
				        .style('stroke-width', '2px')			
				d3.select(this)
					.append('line')
				        .attr('class', 'min')
				        .attr('x1', xScale(d[minVariable]) - xScale(d[medianVariable]))
				        .attr('x2', xScale(d[minVariable]) - xScale(d[medianVariable]))
				        .attr('y1', -8)
				        .attr('y2', 8)
				        .style('stroke', 'black')
				        .style('stroke-width', '2px')
				d3.select(this)
	        		.append('rect')
				        .attr('class', 'range')
				        .attr('x', xScale(d[q1Variable]) - xScale(d[medianVariable]))
				        .attr('y', -8)
				        .attr('height', 16)
				        .attr('width', xScale(d[q3Variable]) - xScale(d[q1Variable]))
				        .style('fill', 'white')
				        .style('stroke', 'black')
				        .style('stroke-width', '2px')
					.on("mouseover", function(d) {
			            div.transition()		
			                .duration(200)		
			                .style("opacity", 1);		
			            div	.html('<strong>'+'median : '+'</strong>'+ d3.format(",.0f")(d.median) + "<br/>" +'<strong>'+'max : '+'</strong>'+d3.format(",.0f")(d.max) + "<br/>"  + '<strong>'+'min : '+'</strong>'+d3.format(",.0f")(d.min))	
			                .style("left", (d3.event.pageX) + "px")		
			                .style("top", (d3.event.pageY - 28) + "px");
									d3.select(this).style('fill', '#ff0000')			
	     			})
			.on("mouseout", function(d) {		
	            div.transition()		
	                .duration(500)		
	                .style("opacity", 0);
				d3.select(this).style('fill', 'white')	
	        })
				d3.select(this)
			        .append('line')
				        .attr('x1', 0)
				        .attr('x2', 0)
				        .attr('y1', -8)
				        .attr('y2', 8)
				        .style('stroke', '#852121')
				        .style('stroke-width', '4px')
			})

		for (i = 0; i<kmer_list.length; i++) {
			d3.select('#'+kmer_list[i]+'_box').style('fill', tsne_colors[i])
			d3.select('#'+kmer_list[i]+'_box').style('opacity', 0.3)
			d3.select('#'+kmer_list[i]+'_box').style('stroke', 'none')
		}
	}
}

function loading_gif(){
	console.log('gif loading')
	d3.select("#tsne")
		.append("svg:image")
		    .attr('x', 220)
		    .attr('y',130)
		    .attr('width', 100)
		    .attr('height', 140)
		    .attr("xlink:href", "./images/ajax-loader.gif")
}


// for selected kmers
function draw_clicked_boxplot(clicked_kmers, clicked_colors){
	d3.select('.viewport_selected').selectAll('*').remove()
	d3.csv(folder+'/boxplot_data.csv', function(data) {
		all_data = data
		clicked_data = []
		
		//Selecting only the clicked kmer data
		for (i = 0; i < clicked_kmers.length; i++ ) { 
			clicked_data.push(data.filter(datum => datum.kmer == clicked_kmers[i])[0])
		}

		data = clicked_data
		kmerValues = clicked_kmers
		var w = 580
		var h = 7500*clicked_data.length /kmer_number
		var margin = {
		    top: 20,
		    bottom: 20,
		    left: 20,
		    right: 30
		 }

		d3.select('.viewport_selected')
		    .append('svg')
		    .attr('height', h)
		    .attr('width', w)

		var catVariable = 'order'
		var catValues = data.map(d => Number(d[catVariable]))
		var kmerValues = data.map(d => d['kmer'])
		const minVariable = 'min'
	    const maxVariable = 'max'
	    const medianVariable = 'median'
	    const q1Variable = 'q1'
	    const q3Variable = 'q3'
		var xScale = d3.scaleLinear()
				.domain([0,8000])
				.range([margin.left, w- margin.right-50])
		/*var yScale = d3.scaleLinear()
				.domain([
					Number(d3.max(data, d => d[catVariable])) + 1,
					Number(d3.min(data, d => d[catVariable])) - 1
				])
				.range([h - margin.bottom, margin.top])	
	  */
	
		var yScale = d3.scalePoint()
				.domain(kmerValues)
				.range([margin.top,h - margin.bottom])
		/*var xAxis = d3.axisBottom()
									.scale(xScale)
									.ticks(10)
									.tickSize(-470) 
					
		d3.select('svg')
			.append('g')
			.attr('transform', 'translate(0,480)')
			.attr('id', 'xAxisG')
			.call(xAxis) */
		var yAxis = d3.axisRight()
						.scale(yScale)
						.tickSize(0)
					//.tickValues(catValues)
						//.tickValues(kmerValues)
								
	
	d3.select('.viewport_selected').select('svg')
		.append('g')
		.style("font", "14px times")
		.style("font-weight", "bold")
		.attr('transform', 'translate(0,0)')
		.attr('id', 'yAxisG')
		.call(yAxis)

	d3.select('.viewport_selected').select('svg')
		.selectAll('g.box')
		.data(data)
		.enter()
		.append('g')
		.attr('class', 'box')
		.attr(
			'transform', d => `translate(${xScale(d[medianVariable])+40},${yScale(d['kmer'])})`
		)
		
		.each(function(d, i) {
			d3.select(this)
		        .append('rect')
		        //.attr('class', 'cover')
		        .attr('x', -150)
		        .attr('y', -10)
		        .attr('height', 20)
		        .attr('width', 480)
		        .style('fill', clicked_colors[i])
		        .style('stroke', 'none')
		        .style('stroke-width', '1px')
				.style('opacity', 0.3)
				.on("click", function(d) {
					// remove signal plots
					d3.selectAll('.line_click').remove()
					d3.selectAll('.line_hover').remove()
					d3.selectAll('.line_brush').remove()
					data_click = []
					data_hover = []
					data_brush = []
					data_brush_byKmer = {}

					box_colors.push(d3.select(this).style("fill"))
					tsne_colors.splice(tsne_colors.indexOf(d3.select(this).style("fill")),1)
					index = kmer_list.indexOf(d.kmer)
					kmer_list.splice(index, 1)

					// remove color from the all-kmer panel
					clicked_id = d.kmer+'_box'
					d3.select('#'+clicked_id).style('fill','white')
					d3.select('#'+clicked_id).style('opacity',0)
					
					// redraw clicked boxplot
					draw_clicked_boxplot(kmer_list, tsne_colors)
					
					// redraw t-SNE
					if (kmer_list.length == 1) {
							combine_1_kmer(kmer_list)
					} else if (kmer_list.length == 2) {
							combine_2_kmers(kmer_list)
					} else if (kmer_list.length == 3) {
							combine_3_kmers(kmer_list)
					} else if (kmer_list.length == 4) {
							combine_4_kmers(kmer_list)
					} else{
							d3.select('#tsne').selectAll('circle').remove()
					}
				})
				
				.on('mouseover', function(){
					/*
					previous_color = d3.select(this).style('fill')
					previous_opacity = d3.select(this).style('opacity')
					d3.select(this)
						.style('fill', 'white')
				        .style('stroke', 'black')
					    .style('stroke-width', 3)
						.style('opacity', 0.4)
					*/

					d3.select(this)
						.style('stroke', 'black')
					    .style('stroke-width', 3)

					// Execute only if there is an element in brush (to avoid throwing error)   
					if (!jQuery.isEmptyObject(data_brush_byKmer)) {
						data_hover = data_brush_byKmer[d.kmer] 	
						draw_signal(data_click,data_hover, data_brush)
					}
				})

				
				.on('mouseout', function(){
					/*
					d3.select(this)
						.style('fill', previous_color)
						.style('opacity', previous_opacity)
						.style('stroke', 'none')
					*/
					d3.select(this)
						
						.style('stroke', 'none')
					draw_signal(data_click,data_hover = [] , data_brush)

				})
				
			d3.select(this)
				.append('line')
					.attr('class', 'range')
					.attr('x1', xScale(d[maxVariable]) - xScale(d[medianVariable]))
			        .attr('x2', xScale(d[minVariable]) - xScale(d[medianVariable]))
			        .attr('y1', 0)
			        .attr('y2', 0)
			        .style('stroke', 'black')
			        .style('stroke-width', '2px')

			d3.select(this)
		        .append('line')
			        .attr('class', 'max')
			        .attr('x1', xScale(d[maxVariable]) - xScale(d[medianVariable]))
			        .attr('x2', xScale(d[maxVariable]) - xScale(d[medianVariable]))
			        .attr('y1', -10)
			        .attr('y2', 10)
			        .style('stroke', 'black')
			        .style('stroke-width', '2px')	

			d3.select(this)
				.append('line')
			        .attr('class', 'min')
			        .attr('x1', xScale(d[minVariable]) - xScale(d[medianVariable]))
			        .attr('x2', xScale(d[minVariable]) - xScale(d[medianVariable]))
			        .attr('y1', -10)
			        .attr('y2', 10)
			        .style('stroke', 'black')
			        .style('stroke-width', '2px')

			d3.select(this)
		        .append('rect')
			        .attr('class', 'range')
			        .attr('x', xScale(d[q1Variable]) - xScale(d[medianVariable]))
			        .attr('y', -10)
			        .attr('height', 20)
			        .attr('width', xScale(d[q3Variable]) - xScale(d[q1Variable]))
			        .style('fill', 'white')
			        .style('stroke', 'black')
			        .style('stroke-width', '2px')
					.on("mouseover", function(d) {
			            div.transition()		
			                .duration(200)		
			                .style("opacity", 1);		
			            div	.html('<strong>'+'median : '+'</strong>'+ d3.format(",.0f")(d.median) + "<br/>" +'<strong>'+'max : '+'</strong>'+d3.format(",.0f")(d.max) + "<br/>"  + '<strong>'+'min : '+'</strong>'+d3.format(",.0f")(d.min))	
			                .style("left", (d3.event.pageX) + "px")		
			                .style("top", (d3.event.pageY - 28) + "px");
									d3.select(this).style('fill', '#ff0000')			
	     			})

					.on("mouseout", function(d) {		
			            div.transition()		
			                .duration(500)		
			                .style("opacity", 0);
							d3.select(this).style('fill', 'white')	
			        })

			d3.select(this)
		        .append('line')
			        .attr('x1', 0)
			        .attr('x2', 0)
			        .attr('y1', -10)
			        .attr('y2', 10)
			        .style('stroke', '#852121')
			        .style('stroke-width', '4px')
		})
	})
}

// a function to download a csv file, given an array of arrays (array_export)
function download_csv() {
	console.log(array_export)					
    var csv = 'kmer,length,read_ID,values\n';
    array_export.forEach(function(row) {
	    csv += row.join(',');
	    csv += "\n";
    });

	var hiddenElement = document.createElement('a');
	hiddenElement.href = 'data:text/csv;charset=utf-8,' + encodeURI(csv);
	hiddenElement.target = '_blank';
	hiddenElement.download = 'data.csv';
	hiddenElement.click();
}		

d3.csv(folder+'/signal_length_max.csv', function(data) {
	var max_signal_length = data[0]['max_length']
	// initialize raw signal plot on landing page
	var signal_init = {
		m : [20, 40, 20, 90], // margins
		w : 800 - 40 - 90, // width
		h : 270 - 20 - 20 // height
	}
	var graph_signal = d3.select(".raw_signal").append("svg:svg")
			.attr("width", signal_init.w + signal_init.m[1] + signal_init.m[3])
			.attr("height", signal_init.h + signal_init.m[0] + signal_init.m[2])
			.attr("id", "signal")
		.append("svg:g")
			.attr("transform", "translate(" + signal_init.m[1] + "," + signal_init.m[0] + ")")
		
		var xScale_signal = d3.scaleLinear()
							.domain([0, max_signal_length]) //set max value to fix the x-axis
							.range([0, signal_init.w]);

		 var yScale_signal = d3.scaleLinear().domain([0, 0]).range([signal_init.h, 0]); 

		// create xAxis
		var xAxis_signal = d3.axisBottom()
					.scale(xScale_signal)
					.tickSize(-signal_init.h)
					//.tickSubdivide(true);
		// Add the x-axis.
		graph_signal.append("svg:g")
				.attr("class", "x axis")
				.attr("transform", "translate(0," + signal_init.h + ")")
				.call(xAxis_signal);
		graph_signal.append("text")
				.attr("transform", "translate(727,235)")
				.style("text-anchor","middle")
				.text("time (ms)")

		// create yaxis
		var yAxis_signal = d3.axisLeft()
				.scale(yScale_signal)
		
		graph_signal.append("svg:g")
				.attr("class", "y axis")
				.attr("transform", "translate(0,0)")
				.call(yAxis_signal);		

		graph_signal.append("text")
				.attr("transform", "translate(12,-5)")
				.style("text-anchor","middle")
				.text("current (mA)")

})
var array_export 

// draw raw signals based on the data passed from add_signal
function draw_signal(data_click,data_hover, data_brush) {
	d3.csv(folder+'/signal_length_max.csv', function(data) {
		
		// for making the length of raw signal plot flexible
		max_list = []
		for (i=0; i<data.length; i++) {
			if(kmer_list.includes(Object.values(data[i])[0])){
				max_list.push(Object.values(data[i])[1])
			}
		}	
		max_signal_length = Math.max(...max_list)
		

		 // preparing for download_csv() by converting an array of objects(data_export) to an array of arrays(array_export)
		 data_export = data_export_click.concat(data_export_brush)
		 array_export = data_export.map(function(obj) {
			return Object.keys(obj).sort().map(function(key) { 
			return obj[key];
			});
		});

		var data = data_hover.concat(data_click).concat(data_brush).concat(data_ave)
		
		var m = [20, 40, 20, 90]; // margins
    	var w = 800 - m[1] - m[3]; // width
    	var h = 270 - m[0] - m[2]; // height
    	 
    	
    	// X scale will fit all values from data[] within pixels 0-w
    	/*var x_max = 0;
    	for (var i = data_brush.length - 1; i >= 0; i--) {
    	    if (data_brush[i].length > x_max) x_max = data_brush[i].length;
    	};*/
    	var x = d3.scaleLinear()
					.domain([0, max_signal_length]) //set max value to fix the x-axis
					.range([0, w]);
    	// Y scale will fit values from 0-10 within pixels h-0 (Note the inverted domain for the y-scale: bigger is up!)
    	
		var min = 999999;
		var max = 0;
		for (var i = data.length - 1; i >= 0; i--) {
    	    if(Math.max.apply(Math, data[i]) > max) max = Math.max.apply(Math, data[i])
			if(Math.min.apply(Math, data[i]) < min) min = Math.min.apply(Math, data[i])
    	};
				
    	var y = d3.scaleLinear().domain([min, max]).range([h, 0]); 
				
    	// automatically determining max range can work something like this
    	//var y = d3.scaleLinear().domain([0, d3.max(data_hover[0])]).range([h, 0]);
    	// create a line function that can convert data[] into x and y points
    	var line = d3.line()
    	// assign the X function to plot our line as we wish
    	.x(function(d, i) {
    	    
    	    // return the X coordinate where we want to plot this datapoint
    	    return x(i);
    	}).y(function(d) {
    	    
    	    // return the Y coordinate where we want to plot this datapoint
    	    return y(d);
    	})
    	// Add an SVG element with the desired dimensions and margin.
		d3.select(".raw_signal").selectAll('*').remove()
    	var graph = d3.select(".raw_signal")
					.append("svg:svg")
						.attr("width", w + m[1] + m[3])
						.attr("height", h + m[0] + m[2])
						.attr("id", "signal")
					.append("svg:g")
						.attr("transform", "translate(" + m[1] + "," + m[0] + ")")
					
    	// create xAxis
    	var xAxis = d3.axisBottom()
					.scale(x)
					.tickSize(-h)
					//.tickSubdivide(true);
    	// Add the x-axis.
    	graph.append("svg:g")
				.attr("class", "x axis")
				.attr("transform", "translate(0," + h + ")")
				.call(xAxis);
    	graph.append("text")
				.attr("transform", "translate(730,235)")
				.style("text-anchor","middle")
				.text("time (ms)")


		// create yaxis
		var yAxis = d3.axisLeft()
				.scale(y)
		
		graph.append("svg:g")
				.attr("class", "y axis")
				.attr("transform", "translate(0,0)")
				.call(yAxis);		

		graph.append("text")
				.attr("transform", "translate(12,-5)")
				.style("text-anchor","middle")
				.text("current (mA)")

				// add lines
    	// do this AFTER the axes above so that the line is above the tick-lines
				
		// signal plots for the clicked points
		graph.selectAll(".line")
			.data(data_click)
			.enter().append("svg:path")
						.attr("d", line)
						.attr("class","line_click")
						.attr('transform', function(d) {
	    						if (d3.select("#normalize_checkbox").property("checked")) {
	    							return 'scale(' + (1/(d.length/max_signal_length)) + ' 1)';
	    						}
	    						else {
	    							return null;
	    						}
	    					})
	    					.attr('vector-effect', 'non-scaling-stroke')	

		// signal plot for the hovered point				
		graph.selectAll(".line")
			.data(data_hover)
			.enter().append("svg:path")
						.attr("d", line)
						.attr("class","line_hover")
						.attr('transform', function(d) {
	    						if (d3.select("#normalize_checkbox").property("checked")) {
	    							return 'scale(' + (1/(d.length/max_signal_length)) + ' 1)';
	    						}
	    						else {
	    							return null;
	    						}
	    					})
	    					.attr('vector-effect', 'non-scaling-stroke')	
				
		// signal plots for the brushed points
		if(d3.select("#average_checkbox").property("checked")) {
			console.log(data_ave)
			graph.selectAll(".line")
				.data(data_ave)
				.enter().append("svg:path")
							.attr("d", line)
							.attr("class", "line_ave")
							.attr('transform', function(d) {
		    						if (d3.select("#normalize_checkbox").property("checked")) {
		    							return 'scale(' + (1/(d.length/max_signal_length)) + ' 1)';
		    						}
		    						else {
		    							return null;
		    						}
		    					})
		    					.attr('vector-effect', 'non-scaling-stroke')
		    					.attr("id", function(d,i){return "line_ave_"+d; })  
							.on("mouseover",function(d){d3.select(this).style("stroke-width",3)})
							.on("mouseout",function(d){d3.select(this).style("stroke-width",1)})
		} else {
			console.log(data_brush)
			graph.selectAll(".line")
				.data(data_brush)
				.enter().append("svg:path")
							.attr("d", line)
							.attr("class", "line_brush")
							.attr('transform', function(d) {
		    						if (d3.select("#normalize_checkbox").property("checked")) {
		    							return 'scale(' + (1/(d.length/max_signal_length)) + ' 1)';
		    						}
		    						else {
		    							return null;
		    						}
		    					})
		    					.attr('vector-effect', 'non-scaling-stroke')
		    					.attr("id", function(d,i){return "line_brush_"+d; })  
							.on("mouseover",function(d){d3.select(this).style("stroke-width",3)})
							.on("mouseout",function(d){d3.select(this).style("stroke-width",1)})

		}
		putNodeOnTop(d3.selectAll(".line_hover").nodes());
	})
}

function putNodeOnTop(node) {
   var n = jQuery(node);
   n.parent().append(n.detach());
}


function combine_1_kmer(kmer_list){
		kmer1 = kmer_list[0]
		
		folder1 = folder+'/distance_matrices/'+kmer1
		
		queue()
		.defer(d3.csv, folder1 + '/' + kmer1 + '_' + kmer1 + '.csv')
		.await(combine_csv)
	function combine_csv(error, file1) {
		if(error) {console.log(error);}
		
		// Convert array of objects to array of arrays
		file1 = file1.map(obj => Object.values(obj));
		
		// call update_tsne
		kmer_size =  [file1.length]
		update_tsne(file1, kmer_list, kmer_size)
	}
}

function combine_2_kmers(kmer_list){
		kmer1 = kmer_list[0]
		kmer2 = kmer_list[1]
		folder1 = folder+'/distance_matrices/'+kmer1
		folder2 = folder+'/distance_matrices/'+kmer2
		queue()
			.defer(d3.csv, folder1 + '/' + kmer1 + '_' + kmer1 + '.csv')
			.defer(d3.csv, folder1 + '/' + kmer1 + '_' + kmer2 + '.csv')
			.defer(d3.csv, folder2 + '/' + kmer2 + '_' + kmer1 + '.csv')
			.defer(d3.csv, folder2 + '/' + kmer2 + '_' + kmer2 + '.csv')
			.await(combine_csv)
	function combine_csv(error, file1, file2, file3, file4) {
		if(error) {console.log(error);}
		
		// Convert array of objects to array of arrays
		file1 = file1.map(obj => Object.values(obj));
		file2 = file2.map(obj => Object.values(obj));
		file3 = file3.map(obj => Object.values(obj));
		file4 = file4.map(obj => Object.values(obj));
		
		// column concat
		kmer1_row = file1.map((value,index) => { return value.concat(file2[index]) });
		kmer2_row = file3.map((value,index) => { return value.concat(file4[index]) });
		// row concat
		combined_matrix = kmer1_row.concat(kmer2_row)
		
		// call update_tsne

		kmer_size =  [file1.length, file4.length]
		update_tsne(combined_matrix, kmer_list, kmer_size)
	}
}

function combine_3_kmers(kmer_list){
		kmer1 = kmer_list[0]
		kmer2 = kmer_list[1]
		kmer3 = kmer_list[2]
		folder1 = folder+'/distance_matrices/'+kmer1
		folder2 = folder+'/distance_matrices/'+kmer2
		folder3 = folder+'/distance_matrices/'+kmer3
		queue()
			.defer(d3.csv, folder1 + '/' + kmer1 + '_' + kmer1 + '.csv')
			.defer(d3.csv, folder1 + '/' + kmer1 + '_' + kmer2 + '.csv')
			.defer(d3.csv, folder1 + '/' + kmer1 + '_' + kmer3 + '.csv')
			.defer(d3.csv, folder2 + '/' + kmer2 + '_' + kmer1 + '.csv')
			.defer(d3.csv, folder2 + '/' + kmer2 + '_' + kmer2 + '.csv')
			.defer(d3.csv, folder2 + '/' + kmer2 + '_' + kmer3 + '.csv')
			.defer(d3.csv, folder3 + '/' + kmer3 + '_' + kmer1 + '.csv')
			.defer(d3.csv, folder3 + '/' + kmer3 + '_' + kmer2 + '.csv')
			.defer(d3.csv, folder3 + '/' + kmer3 + '_' + kmer3 + '.csv')
			.await(combine_csv)
	function combine_csv(error, file1, file2, file3, file4, file5, file6, file7, file8, file9) {
		if(error) {console.log(error);}
		
		// Convert array of objects to array of arrays
		file1 = file1.map(obj => Object.values(obj));
		file2 = file2.map(obj => Object.values(obj));
		file3 = file3.map(obj => Object.values(obj));
		file4 = file4.map(obj => Object.values(obj));
		file5 = file5.map(obj => Object.values(obj));
		file6 = file6.map(obj => Object.values(obj));
		file7 = file7.map(obj => Object.values(obj));
		file8 = file8.map(obj => Object.values(obj));
		file9 = file9.map(obj => Object.values(obj));
		
		// column concat
		kmer1_row = file1.map((value,index) => { return value.concat(file2[index]).concat(file3[index]) });
		kmer2_row = file4.map((value,index) => { return value.concat(file5[index]).concat(file6[index]) });
		kmer3_row = file7.map((value,index) => { return value.concat(file8[index]).concat(file9[index]) });
		// row concat
		combined_matrix = kmer1_row.concat(kmer2_row).concat(kmer3_row)
				
		// call update_tsne
		kmer_size =  [file1.length, file5.length, file9.length]
		update_tsne(combined_matrix, kmer_list, kmer_size)
	}
}
function combine_4_kmers(kmer_list){
		kmer1 = kmer_list[0]
		kmer2 = kmer_list[1]
		kmer3 = kmer_list[2]
		kmer4 = kmer_list[3]
		folder1 = folder+'/distance_matrices/'+kmer1
		folder2 = folder+'/distance_matrices/'+kmer2
		folder3 = folder+'/distance_matrices/'+kmer3
		folder4 = folder+'/distance_matrices/'+kmer4
		queue()
			.defer(d3.csv, folder1 + '/' + kmer1 + '_' + kmer1 + '.csv')
			.defer(d3.csv, folder1 + '/' + kmer1 + '_' + kmer2 + '.csv')
			.defer(d3.csv, folder1 + '/' + kmer1 + '_' + kmer3 + '.csv')
			.defer(d3.csv, folder1 + '/' + kmer1 + '_' + kmer4 + '.csv')
			.defer(d3.csv, folder2 + '/' + kmer2 + '_' + kmer1 + '.csv')
			.defer(d3.csv, folder2 + '/' + kmer2 + '_' + kmer2 + '.csv')
			.defer(d3.csv, folder2 + '/' + kmer2 + '_' + kmer3 + '.csv')
			.defer(d3.csv, folder2 + '/' + kmer2 + '_' + kmer4 + '.csv')
			.defer(d3.csv, folder3 + '/' + kmer3 + '_' + kmer1 + '.csv')
			.defer(d3.csv, folder3 + '/' + kmer3 + '_' + kmer2 + '.csv')
			.defer(d3.csv, folder3 + '/' + kmer3 + '_' + kmer3 + '.csv')
			.defer(d3.csv, folder3 + '/' + kmer3 + '_' + kmer4 + '.csv')
			.defer(d3.csv, folder4 + '/' + kmer4 + '_' + kmer1 + '.csv')
			.defer(d3.csv, folder4 + '/' + kmer4 + '_' + kmer2 + '.csv')
			.defer(d3.csv, folder4 + '/' + kmer4 + '_' + kmer3 + '.csv')
			.defer(d3.csv, folder4 + '/' + kmer4 + '_' + kmer4 + '.csv')
			.await(combine_csv)
	function combine_csv(error, file1, file2, file3, file4, file5, file6, file7, file8, file9, file10, file11, file12, file13, file14, file15, file16) {
		if(error) {console.log(error);}
		
		// Convert array of objects to array of arrays
		file1 = file1.map(obj => Object.values(obj));
		file2 = file2.map(obj => Object.values(obj));
		file3 = file3.map(obj => Object.values(obj));
		file4 = file4.map(obj => Object.values(obj));
		file5 = file5.map(obj => Object.values(obj));
		file6 = file6.map(obj => Object.values(obj));
		file7 = file7.map(obj => Object.values(obj));
		file8 = file8.map(obj => Object.values(obj));
		file9 = file9.map(obj => Object.values(obj));
		file10 = file10.map(obj => Object.values(obj));
		file11 = file11.map(obj => Object.values(obj));
		file12 = file12.map(obj => Object.values(obj));
		file13 = file13.map(obj => Object.values(obj));
		file14 = file14.map(obj => Object.values(obj));
		file15 = file15.map(obj => Object.values(obj));
		file16 = file16.map(obj => Object.values(obj));
		
		
		// column concat
		kmer1_row = file1.map((value,index) => { return value.concat(file2[index]).concat(file3[index]).concat(file4[index]) });
		kmer2_row = file5.map((value,index) => { return value.concat(file6[index]).concat(file7[index]).concat(file8[index]) });
		kmer3_row = file9.map((value,index) => { return value.concat(file10[index]).concat(file11[index]).concat(file12[index]) });
		kmer4_row = file13.map((value,index) => { return value.concat(file14[index]).concat(file15[index]).concat(file16[index]) });
		// row concat
		combined_matrix = kmer1_row.concat(kmer2_row).concat(kmer3_row).concat(kmer4_row)
				
		// call update_tsne
		kmer_size =  [file1.length, file6.length, file11.length, file16.length]
		update_tsne(combined_matrix, kmer_list, kmer_size)
	}
}

// get positions of the t-sne plot before passing it to draw_tsne
//var target = document.getElementById("tsne");
var target = d3.select(".tsne").node();

var kmer_size;
var tsne_data;
function update_tsne(data, kmer_list, kmer_size) {
	tsne_data = data
	kmer_size = kmer_size
	var dists = data.map(obj => Object.values(obj));
	tsne.initDataDist(dists);
	for(var k = 0; k < 250; k++) {
			tsne.step(); // every time you call this, solution gets better
	}
	var Y = tsne.getSolution(); 
	
	
	draw_tsne(Y, kmer_list, kmer_size)
	
}


// interface for tsne parameters 

var sliderPerplexity = d3
    .sliderBottom()
    .min(5)
    .max(50)
    .width(180)
    .tickFormat(d3.format('d'))
    .ticks(1)
    .default(opt.perplexity)
    .on('onchange', val => {
     	opt.perplexity = Math.round(val);
     	
    });

var sliderLearnRate = d3
    .sliderBottom()
    .min(10)
    .max(1000)
    .width(180)
    .tickFormat(d3.format('d'))
    .ticks(1)
    .default(opt.epsilon)
    .on('onchange', val => {
     	opt.epsilon = Math.round(val);
		
    });    

var svgParameters = d3
    .select('#slider-parameters')
    .append('svg')
    .attr('width', 350)
    .attr('height', 200)

// Perplexity
svgParameters.append('text')
    .text('perplexity')
    .attr('y', 35)    

svgParameters.append('g')
	.attr('transform', 'translate(130,30)')
	.call(sliderPerplexity);

// Learning Rate
svgParameters.append('text')
    .text('Learning Rate')
    .attr('y', 85)    

svgParameters.append('g')
	.attr('transform', 'translate(130,80)')
	.call(sliderLearnRate);

function redraw_tsne(){
	console.log(opt)
	d3.select('#tsne').selectAll('circle').remove()	
	loading_gif()
	tsne = new tsnejs.tSNE(opt)
	update_tsne(tsne_data, kmer_list, kmer_size)
}

</script>
</body>

</html>


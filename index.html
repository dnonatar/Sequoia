<!DOCTYPE html>
<html>

<head>
<script src="//d3js.org/d3.v4.min.js"></script>
<script src='//raw.githack.com/karpathy/tsnejs/master/tsne.js'></script>
<script src="//d3js.org/queue.v1.min.js"></script>
<script src="//ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>


<style>
            /* tell the SVG path to be a thin blue line without any area fill */
				path { 
					stroke-width: 1; 
					fill: none; 
				} 
				.line_hover { 
					stroke: #ff0000; 
					stroke-width: 3;
					opacity : 1;
				} 
				.line_click {
        			stroke: black; 
					opacity : 0.5;
				}
				.line_brush {
        			stroke: black;
					opacity : 0.5;
				}  
				.axis { 
					shape-rendering: crispEdges; 
				} 
				.x.axis line {
        			stroke: lightgrey; 
				} .x.axis 
				.minor { 
					stroke-opacity: .5; 
				} 
				.x.axis path { 
					display: black; 
				} 
				.x.axis text { 
					font-size: 14; 
				} 
				.y.axis line, .y.axis
	            path { fill: none; stroke: #000; } .y.axis text { font-size: 14; } .y.axisRight
	            text { fill: orange; } .y.axisLeft text { fill: steelblue; } 
				
				.kmer-filter {
		            position: absolute;
		            top: 70px;
		            left: 20px;
         		}
				.button {
		            position: absolute;
		            top: 45px;
		            left: 20px;
	      		}

	      		.plot_type {
		            position: absolute;
		            top: 45px;
		            left: 300px;
	      		}

				.choose-folder {
		            position: absolute;
		            top: 15px;
		            left: 20px;
	     		}
				
				.viewport {
		            position: absolute;
		            top: 100px;
		            left: 15px;
		            overflow: auto;
		            width: 360px;
		            height: 400px;
		            background-color: #e8e8e8;
		            border: 1px solid #AAAAAA;
		            border-radius: 4px;
		            box-shadow: inset 1px 1px 6px 2px rgba(0,0,0, .25);
        		}

				.viewport_selected_text {
					position: absolute;
					top: 500px;
        			left: 15px;
				}

				.viewport_selected {
		            position: absolute;
		            top: 540px;
		            left: 15px;
		            overflow: auto;
		            width: 360px;
		            height: 120px;
		            background-color: #e8e8e8;
		            border: 1px solid #AAAAAA;
		            border-radius: 4px;
		            box-shadow: inset 1px 1px 6px 2px rgba(0,0,0, .25);
			    }
		
				.normalize_checkbox {
					position: absolute;
					top: 500px;
	            	left: 930px;
				}

				.export_button {
					position: absolute;
					top: 550px;
	            	left: 930px;
				}

				.reset_button {
					position: absolute;
					top: 600px;
		        	left: 930px;
				}

				.tsne {
		            position: absolute;
		            top: 270px;
		            left: 400px;
		            
		        }
				.raw_signal {
		            position: absolute;
		            top: 10px;
		            left: 400px;
		            width: 350px;
		            height: 200px;
		        }
				div.tooltip {	
    				position: absolute;			
    				text-align: center;			
    				width: 100px;					
    				height: 48px;					
    				padding: 2px;				
    				font: 12px sans-serif;		
    				background: lightsteelblue;	
    				border: 0px;		
   				 	border-radius: 8px;			
    				pointer-events: none;			
				}
				.brushed {
		            opacity: 1.0;
		        }
		        .non_brushed {
		            opacity: 0.7;
		        }
				
					
</style>
</head>

<body style='font-family="sans-serif"'>
<div class = "button">
	<form id="sort">
		<div> Sort by
			<input type='radio' id="sort_kmer" name="mode" checked>k-mer</input> 
			<input  type='radio' id="sort_median" name="mode">median</input>
			<input  type='radio' id="sort_max" name="mode">max</input>
	  	</div>
	</form>
</div>

<div class = "plot_type">
	<select id="plot_type">
		<option value="box" selected="selected">Box Plot</option>
		<option value="violin">Violin Plot</option>
	</select>
</div>

<div class = "kmer-filter">
	<form name="myform" onkeyup="return handleType()">k-mer filtering  
    	<input type="text" id="myVal1" placeholder="Partial or Full k-mer">
	</form>
</div>

<div class = "choose-folder">
	<form name="myform" onSubmit="return handleFolder()">
		<input name="Submit"  type="submit" value="Choose" >
    	<input type="text" id="folder" placeholder="Type Input Folder">
	</form>
</div>

<div class = "viewport"></div>
<div class = "viewport_selected_text">
	<p><b>Selected k-mers (up to 4)</b></p>
</div>
<div class = "viewport_selected"></div>
<div class = "tsne", id="tsnee">
<!--<svg width="500" height="500">
  <rect width="400" height="400" style="fill:none;stroke-width:1;stroke:rgb(0,0,0)" />
</svg>-->
</div>
<div class = "raw_signal"></div>

<div class = "export_button">
	<button onclick="download_csv()">Download CSV</button> (export selected points)
</div>

<!--<div class = "reset_button">
	<button onclick="reset()"> Reset </button> 
</div>-->

<div class = "normalize_checkbox">
	<input type="checkbox" id="normalize_checkbox"> Normalization Mode (click before brush)
<div>

<script type="text/javascript">
var box_colors = ["rgb(51, 160, 44)","rgb(31, 120, 180)","rgb(0, 0, 0)","rgb(255, 127, 0)"]
var tsne_colors = []
var folder = 'data'


function reset() {
	d3.select("").selectAll('*').remove()
}

// On landing page, use 'data' as a default folder
d3.csv('data'+'/boxplot_data.csv', function(data) {
	//folder='data'
	function changeBoxplot(){
		d3.select(".viewport").selectAll("*").remove()
		var form = document.getElementById("sort")
		var form_val;
		for(var i=0; i<form.length; i++){
		  if(form[i].checked){
		    form_val = form[i].id;}} 
		
		draw_boxplot(data, form_val)
	}	

	//when changing sorting option
	var dataSort = d3.select("#sort")
	dataSort.on("change", function(){
		var sect = document.getElementById("plot_type");
		var section = sect.options[sect.selectedIndex].value;

		if (section == 'violin') {
			draw_violin(filtered_data_violin=[],filtered_data_box=[]);
		} else {
			changeBoxplot();			
		}

	})

	draw_boxplot(data, 'kmer')

	// When changing plot type
	d3.select(".plot_type").on("change",function(){
		
		var sect = document.getElementById("plot_type");
		var section = sect.options[sect.selectedIndex].value;
		
		if (section == 'violin') {
			draw_violin(filtered_data_violin=[],filtered_data_box=[]);
		} else {
			changeBoxplot();			
		}
	})

})


function draw_violin(filtered_data_violin, filtered_data_box) {

	//d3.select(".viewport").selectAll("*").remove()   // not gonna work if placed here. why?
	file1 = './'+folder+'/boxplot_data.csv'
	file2 = './'+folder+'/violin_data.csv'
	queue()
		.defer(d3.csv, file1)
		.defer(d3.csv, file2)
		.await(get_violin)

	function get_violin(error, file1, file2) {
		d3.select(".viewport").selectAll("*").remove()
		box_data = file1
		violin_data = file2
		if (filtered_data_violin.length != 0){ 
			violin_data = filtered_data_violin
			box_data = filtered_data_box
		}
		
		//get sorting option
		var form = document.getElementById("sort")
		var form_val;

		for(var i=0; i<form.length; i++){
		  if(form[i].checked){
		    form_val = form[i].id;}} 

		if (form_val == 'sort_median') {
			violin_data.sort(function(a,b) {
				return b['median'] - a['median'];
			});
			box_data.sort(function(a,b) {
				return b['median'] - a['median'];
			});
		} else if (form_val == 'sort_kmer') {
			violin_data.sort(function(a,b) {
				var x = a['kmer'].toLowerCase();
				var y = b['kmer'].toLowerCase();
				return x < y ? -1 : x > y ? 1 : 0;
			});
			box_data.sort(function(a,b) {
				var x = a['kmer'].toLowerCase();
				var y = b['kmer'].toLowerCase();
				return x < y ? -1 : x > y ? 1 : 0;
			});
		} else if (form_val == 'sort_max') {
			violin_data.sort(function(a,b) {
				return b['max'] - a['max'];
			});
			box_data.sort(function(a,b) {
				return b['max'] - a['max'];
			});
		}
		

		// set the dimensions and margins of the graph
		var margin = {top: 35, right: 20, bottom: 30, left: 60},
		    width = 360 - margin.left - margin.right,
		    height = 8400 - margin.top - margin.bottom;

		// append the svg object to the body of the page
		var svg = d3.select(".viewport")
		  .append("svg")
		    .attr("width", width + margin.left + margin.right)
		    .attr("height", height + margin.top + margin.bottom)
		  .append("g")
		    .attr("transform",
		          "translate(" + margin.left + "," + margin.top + ")");

		// Read the data and compute summary statistics for each 
		
		var kmerValues = violin_data.map(d => d['kmer'])
		// Build and Show the x scale
		var x = d3.scaleLinear()
		  .domain([ 0,2500 ])          
		  .range([0, width])
		svg.append("g")
			.attr("transform", "translate(" + 0 +","+0+ ")")
			.call( d3.axisTop(x) )
		      .selectAll('text')
		        .style("text-anchor", "start")
		        .attr("transform", "translate(12,-7)rotate(-90)");

		// Build and Show the y scale. It is a band scale like for a boxplot: each group has an dedicated RANGE on the axis.
		console.log(box_data.length) 
		var y = d3.scaleBand()
			.domain(kmerValues)
		    //.range([ 0, height ])
		    .range([ 0, height/256*box_data.length ])
		    .padding(0.05)     //  it is the space between 2 groups. 0 means no padding. 1 is the maximum.
		  svg.append("g")
		  	 .style("font", "14px times")
		    .attr("transform", "translate(" + 0 +","+0+ ")")
		    .call(d3.axisLeft(y))

		  // Features of the histogram
		var histogram = d3.histogram()
		    .domain(x.domain())
		    .thresholds(x.ticks(20))    // Important: how many bins approx are going to be made? It is the 'resolution' of the violin plot
		    .value(d => d)

		// Compute the binning for each group of the dataset
		var sumstat = d3.nest()  // nest function allows to group the calculation per level of a factor
		    .key(function(d) { return d.kmer;})
		    .rollup(function(d) {   // For each key..
		      input = d.map(function(g) { return g.ave_distance;})    // Keep the variable called ave_distance     
		      bins = histogram(input)   // And compute the binning on it.
		      return(bins)
		    })
		    .entries(violin_data)


		// Attach median and max values to sumstat 
		for (i =0; i < box_data.length; i++) {
			sumstat[i]['median'] = box_data[i]['median']
			sumstat[i]['max'] = box_data[i]['max']		
		}
		   
		   

		// What is the biggest number of value in a bin? We need it cause this value will have a width of 100% of the bandwidth.
		var maxNum = 0
		for ( i in sumstat ){
		    allBins = sumstat[i].value
		    lengths = allBins.map(function(a){return a.length;})
		    longest = d3.max(lengths)
		    if (longest > maxNum) { maxNum = longest }
		}

		// The maximum width of a violin must be y.bandwidth = the width dedicated to a group
		var yNum = d3.scaleLinear()
		  	.domain([-maxNum,maxNum])
		    .range([0, y.bandwidth()])
		    

		// Add the shape to this svg!
		violins = svg.selectAll("myViolin")

		    .data(sumstat)
		    .enter()        // So now we are working group per group
		    .append("g")
		      .attr("transform", function(d){ return("translate(0," + y(d.key) +")") } ) // Translation vertically to be at the group position
		    
	    violins.append("path")
	        .datum(function(d){ return(d.value)})     // So now we are working bin per bin
	        .style("stroke", "none")
	        .style("fill","#240acc")
	        .style("opacity",0.5)
	        .attr("d", d3.area()
	            .y0(function(d){ return(yNum(-d.length)) } )
	            .y1(function(d){ return(yNum(d.length)) } )
	            .x(function(d){ return(x(d.x0)) } )
	            .curve(d3.curveCatmullRom)    // This makes the line smoother to give the violin appearance. Try d3.curveStep to see the difference
	            
	        )
	        

	    violins.append('rect')
	        .attr('class', 'cover')
	        .attr('id', function(d){return (d.key +'_violin')})
	        .attr('x', -60)
	        .attr('y', 0)
	        .attr('height', 30)
	        .attr('width', 480)
	        .style('fill', 'white')
	        .style('stroke', 'black')
	        .style('stroke-width', '1px')
			.style('opacity', 0)
			.on("click", function(d) {
				if(kmer_list.length < 4 && kmer_list.includes(d.key)==false) {				
				
					d3.select('#tsne').selectAll('circle').remove()	
					loading_gif()
					
					d3.select(this).style("opacity",0.3)
					d3.select(this).style("stroke",'none')
					d3.select(this).style("fill",box_colors[box_colors.length-1])
					tsne_colors.push(box_colors[box_colors.length-1])	
					box_colors.pop()
					
					// remove selected boxplot from the current viewport
					index = kmerValues.indexOf(d.kmer)
					kmerValues.splice(index, 1)
					/*
					filtered_data = []
					for (i=0;i<data.length;i++) {
						if(kmerValues.includes(data[i]['kmer']) ){
							filtered_data.push(data[i])
						}
					}
					*/

					kmer_list.push(d.key)
					draw_clicked_violin(kmer_list, tsne_colors)
					

					// draw tsne	
					if (kmer_list.length == 1) {
							combine_1_kmer(kmer_list)
					} else if (kmer_list.length == 2) {
							combine_2_kmers(kmer_list)
					} else if (kmer_list.length == 3) {
							combine_3_kmers(kmer_list)
					} else if (kmer_list.length == 4) {
							combine_4_kmers(kmer_list)
					} else{
							d3.select('#tsne').selectAll('circle').remove()
					}
				
				//keep previous color and opacity to be used on mouseout
				previous_color = d3.select(this).style('fill')
				previous_opacity = d3.select(this).style('opacity')
				}
    		})

    		
			.on('mouseover', function(){
				previous_color = d3.select(this).style('fill')
				previous_opacity = d3.select(this).style('opacity')
				d3.select(this)
					.style('fill', 'grey')
			        .style('stroke', 'none')
					.style('opacity', 0.4)
			})
			.on('mouseout', function(){
				d3.select(this)
					.style('fill', previous_color)
					.style('opacity', previous_opacity)
			})

		/*
		d3.select("#sort_median")
			.on("click", function() {
				violins.sort(function(a,b) {
					return d3.descending(Number(a.median),Number(b.median))
				})
				.attr("transform", function(d){ return("translate(0," + y(d.key) +")") } )

				
			})	
		*/

		mybox = d3.select('.viewport').select('svg').select('g')

		mybox.selectAll('circle')
			.data(box_data)
			.enter()
			.append('g')
			.attr('class','violin_median')
			.attr("transform", function(d){ return("translate(0," + y(d.kmer) + ")") } )
			.append('circle')
			.attr('cx', function(d){ return x(d.median)})
			.attr('r', 3)
			.attr('transform', 'translate(' + 0 + ',' + 15 + ')' )
			.style('fill', 'white')
		
		for (i = 0; i<kmer_list.length; i++) {
			d3.select('#'+kmer_list[i]+'_violin').style('fill', tsne_colors[i]) 
			d3.select('#'+kmer_list[i]+'_violin').style('opacity', 0.3) 
			d3.select('#'+kmer_list[i]+'_violin').style('stroke', 'none') 
		}
			
	}
}


function draw_clicked_violin(clicked_kmers, colors) {
	
	d3.select('.viewport_selected').selectAll('*').remove()
	file1 = './'+folder+'/boxplot_data.csv'
	file2 = './'+folder+'/violin_data.csv'
	queue()
		.defer(d3.csv, file1)
		.defer(d3.csv, file2)
		.await(get_violin)

	function get_violin(error, file1, file2) {
		box_data = file1
		violin_data = file2
		
		clicked_violin = []
		clicked_box = []
		for (i=0;i<violin_data.length;i++) {
			if(clicked_kmers.includes(violin_data[i]['kmer']) ){
				clicked_violin.push(violin_data[i])
			}
		}

		for (i=0;i<box_data.length;i++) {
			if(clicked_kmers.includes(box_data[i]['kmer']) ){
				clicked_box.push(box_data[i])
			}
		}

		violin_data = clicked_violin
		box_data = clicked_box    // need this to get the median
		kmerValues = clicked_kmers

		// set the dimensions and margins of the graph
		var margin = {top: 10, right: 20, bottom: 30, left: 60},
		    width = 360 - margin.left - margin.right,
		    height = 280 

		// append the svg object to the body of the page
		var svg = d3.select(".viewport_selected")
		  .append("svg")
		    .attr("width", width + margin.left + margin.right)
		    .attr("height", height )
		  .append("g")
		    .attr("transform",
		          "translate(" + margin.left + "," + margin.top + ")");

		// Read the data and compute summary statistics for each species
		
		  var kmerValues = violin_data.map(d => d['kmer'])
		  // Build and Show the x scale
		  var x = d3.scaleLinear()
		    .domain([ 0,2500 ])          
		    .range([0, width])
		  /*  
		  svg.append("g")
		  	.attr("transform", "translate(" + 0 +","+0+ ")")
		  	.call( d3.axisTop(x) )
		        .selectAll('text')
		          .style("text-anchor", "start")
		          .attr("transform", "translate(12,-7)rotate(-90)");
		  */
		  
		  // Build and Show the y scale. It is a band scale like for a boxplot: each group has an dedicated RANGE on the axis. 
		  var y = d3.scaleBand()
		  	.domain(kmerValues)
		    .range([ 0, height/4*clicked_kmers.length ])
		    .padding(0.05)     //  it is the space between 2 groups. 0 means no padding. 1 is the maximum.
		  svg.append("g")
		  	 .style("font", "14px times")
		    .attr("transform", "translate(" + 0 +","+0+ ")")
		    .call(d3.axisLeft(y))

		  // Features of the histogram
		  var histogram = d3.histogram()
		        .domain(x.domain())
		        .thresholds(x.ticks(20))    // Important: how many bins approx are going to be made? It is the 'resolution' of the violin plot
		        .value(d => d)

		  // Compute the binning for each group of the dataset
		  var sumstat = d3.nest()  // nest function allows to group the calculation per level of a factor
		    .key(function(d) { return d.kmer;})
		    .rollup(function(d) {   // For each key..
		      input = d.map(function(g) { return g.ave_distance;})    // Keep the variable called ave_distance     
		      bins = histogram(input)   // And compute the binning on it.
		      return(bins)
		    })
		    .entries(violin_data)

		  // What is the biggest number of value in a bin? We need it cause this value will have a width of 100% of the bandwidth.
		  var maxNum = 0
		  for ( i in sumstat ){
		    allBins = sumstat[i].value
		    lengths = allBins.map(function(a){return a.length;})
		    longest = d3.max(lengths)
		    if (longest > maxNum) { maxNum = longest }
		  }

		  // The maximum width of a violin must be y.bandwidth = the width dedicated to a group
		  var yNum = d3.scaleLinear()
		  	.domain([-maxNum,maxNum])
		    .range([0, 60])
		    

		  // Add the shape to this svg!
		  violins = svg.selectAll("myViolin")
		    .data(sumstat)
		    .enter()        // So now we are working group per group
		    .append("g")
		      .attr("transform", function(d){ return("translate(0," + y(d.key) +")") } ) // Translation vertically to be at the group position
		    
		    violins.append("path")
		        .datum(function(d){ return(d.value)})     // So now we are working bin per bin
		        .style("stroke", "none")
		        .style("fill","#240acc")
		        .style("opacity",0.7)
		        .attr("d", d3.area()
		            .y0(function(d){ return(yNum(-d.length)) } )
		            .y1(function(d){ return(yNum(d.length)) } )
		            .x(function(d){ return(x(d.x0)) } )
		            .curve(d3.curveCatmullRom)    // This makes the line smoother to give the violin appearance. 
		            
		        )
		        

		    violins.append('rect')
		        .attr('class', 'cover')
		        .attr('x', -60)
		        .attr('y', 0)
		        .attr('height', 60)
		        .attr('width', 480)
		        .style('fill', function(d,i) {return colors[i]} )
		        .style('stroke', 'none')
		        .style('stroke-width', '1px')
				.style('opacity', 0.5)
				
        		.on("click", function(d) {
					box_colors.push(d3.select(this).style("fill"))
					tsne_colors.splice(tsne_colors.indexOf(d3.select(this).style("fill")),1)
					index = kmer_list.indexOf(d.key)
					kmer_list.splice(index, 1)
					
					// remove color from the all-kmer panel
					clicked_id = d.key+'_violin'
					d3.select('#'+clicked_id).style('fill','white')
					d3.select('#'+clicked_id).style('opacity',0)
					
					// redraw clicked violin
					draw_clicked_violin(kmer_list, tsne_colors)
					
					// redraw t-SNE
					if (kmer_list.length == 1) {
							combine_1_kmer(kmer_list)
					} else if (kmer_list.length == 2) {
							combine_2_kmers(kmer_list)
					} else if (kmer_list.length == 3) {
							combine_3_kmers(kmer_list)
					} else if (kmer_list.length == 4) {
							combine_4_kmers(kmer_list)
					} else{
							d3.select('#tsne').selectAll('circle').remove()
					}
			
				})

        		/*
				.on('mouseover', function(){
					previous_color = d3.select(this).style('fill')
					previous_opacity = d3.select(this).style('opacity')
					d3.select(this)
						.style('fill', 'grey')
				        .style('stroke', 'none')
						.style('opacity', 0.4)
				})
				.on('mouseout', function(){
					d3.select(this)
						.style('fill', previous_color)
						.style('opacity', previous_opacity)
				})
				*/
			
			/*
			mybox = d3.select('.viewport_selected').select('svg').select('g')

			mybox.selectAll('circle')
				.data(box_data)
				.enter()
				.append('g')
				.attr('class','violin_median')
				.attr("transform", function(d){ return("translate(0," + y(d.kmer) + ")") } )
				.append('circle')
				.attr('cx', function(d){ return x(d.median)})
				.attr('r', 4)
				.attr('transform', 'translate(' + 0 + ',' + 15 + ')' )
				.style('fill', 'white')
			*/
			/*
			mybox.selectAll('.violin_median').select('rect')
				.data(box_data)
				.enter()
				.append('g')
				.attr('class','violin_box')
				.attr("transform", function(d){ return("translate(0," + y(d.kmer) + ")") } )
				.append('rect')
				.attr('x', function(d){return x(d.q1)})
				.attr('y', 10)
				.attr('width', function(d) {return (x(d.q3) - x(d.q1)) } )
				.attr('height', 10)
				.style('fill', 'black')
				.style('opacity', 0.3)
			*/	
	
	}
}


// function to be called when a folder is chosen
function handleFolder(event){
	folder = document.getElementById("folder").value
	d3.select(".tsne").selectAll('.circle').remove()
	d3.select(".viewport").selectAll("*").remove()

	d3.csv(folder+'/boxplot_data.csv', function(data) {
		function changeBoxplot(){
			d3.select(".viewport").selectAll("*").remove()
			var form = document.getElementById("sort")
			var form_val;
			for(var i=0; i<form.length; i++){
  		  		if(form[i].checked){
  		    		form_val = form[i].id;
  		    	}
  			} 
			
			draw_boxplot(data, form_val)

		}

		// change sort type	
		var dataSort = d3.select("#sort")
		dataSort.on("change", function(){
		var sect = document.getElementById("plot_type");
		var section = sect.options[sect.selectedIndex].value;

		if (section == 'violin') {
			draw_violin(filtered_data_violin=[],filtered_data_box=[]);
		} else {
			changeBoxplot();
		}

	})
		// get the sort type before plotting the boxplots
		var form = document.getElementById("sort")
		var form_val;
		for(var i=0; i<form.length; i++){
	  		if(form[i].checked){
	    		form_val = form[i].id;
	    	}
		} 

		draw_boxplot(data, form_val)
	})

	return false;
}

function handleType(event){

	
	text = document.getElementById("myVal1").value
	if (text.length == 0) {
		text = '*****'
	} else if (text.length == 1) {
		text = text + '****'
	} else if (text.length == 2) {
		text = text + '***'
	}	else if (text.length == 3) {
		text = text + '**'
	} else if (text.length == 4) {
		text = text + '*'
	}
	
	
	file1 = './'+folder+'/boxplot_data.csv'
	file2 = './'+folder+'/violin_data.csv'
	queue()
		.defer(d3.csv, file1)
		.defer(d3.csv, file2)
		.await(filter_text)
		
	function filter_text(error, file1, file2){
		data_box = file1
		data_violin = file2
		var kmerValues = data_box.map(d => d['kmer'])
		function matching(kmer) {
			exact1 = kmer[0] == text[0]
			exact2 = kmer[1] == text[1]
			exact3 = kmer[2] == text[2]
			exact4 = kmer[3] == text[3]
			exact5 = kmer[4] == text[4]
			var exact = [exact1,exact2,exact3,exact4,exact5] 
			
			any1 = kmer[0] == 'A' || kmer[0] == 'T' || kmer[0] == 'G' || kmer[0] == 'C' 
			any2 = kmer[1] == 'A' || kmer[1] == 'T' || kmer[1] == 'G' || kmer[1] == 'C' 
			any3 = kmer[2] == 'A' || kmer[2] == 'T' || kmer[2] == 'G' || kmer[2] == 'C' 
			any4 = kmer[3] == 'A' || kmer[3] == 'T' || kmer[3] == 'G' || kmer[3] == 'C' 
			any5 = kmer[4] == 'A' || kmer[4] == 'T' || kmer[4] == 'G' || kmer[4] == 'C' 
			
			var any = [any1,any2,any3,any4,any5]
 
			var conditions = []
			for (i=0;i<5;i++) {
				if (text[i]=='*') {
					conditions.push(any[i])
				} else {
					conditions.push(exact[i])
				}
			}
			return (conditions[0] && conditions[1] && conditions[2] && conditions[3] && conditions[4])
		}
		filtered_kmers = kmerValues.filter(matching)
		
		// get sorting type
		var form = document.getElementById("sort")
		var form_val;
		for(var i=0; i<form.length; i++){
  	  		if(form[i].checked){
  	    		form_val = form[i].id;}
  		}

		var sect = document.getElementById("plot_type");
		var section = sect.options[sect.selectedIndex].value;

		// get filtered data based on filtered_kmers
		
		filtered_data_box = []
		filtered_data_violin = []

		for (i=0;i<data_box.length;i++) {
			if(filtered_kmers.includes(data_box[i]['kmer']) ){
				filtered_data_box.push(data_box[i])
			}
		}	
		
		for (i=0;i<data_violin.length;i++) {
			if(filtered_kmers.includes(data_violin[i]['kmer']) ){
				filtered_data_violin.push(data_violin[i])
			}
		}
					
				
		// remove and redraw 
		d3.select(".viewport").selectAll("*").remove()
		if (section == 'box') {
			
			draw_boxplot(filtered_data_box, form_val)
			
		} else if (section == 'violin') {

			draw_violin(filtered_data_violin, filtered_data_box)
			
		}
	
	}
	
	
	// return false prevents the page from reloading after submitting		
	return false;
}
	
var opt = {} // epsilon is learning rate (10 = default)
opt.epsilon = 10;
opt.perplexity = 80;
var tsne = new tsnejs.tSNE(opt); // create a tSNE instance


// create t-sne axes on landing page
d3.select('.tsne')
	.append('svg')
	.attr("width", 500)
	.attr("height", 400)
	.attr("id", "tsne")

var xScale_tsne = d3.scaleLinear()
				.domain([0,0])	
				//.range([padding,width - padding * 2])	
				.range([40,500-20])
				.nice();

var yScale_tsne = d3.scaleLinear()
		.domain([0,0])
		//.range([height - padding, padding])
		.range([20, 400-40])
		.nice();

var x_axis = d3.axisBottom()
                   .scale(xScale_tsne);  

d3.select("#tsne").append("g")
	 	.attr("transform", "translate(0,360)")
		.call(x_axis);

d3.select("#tsne").append("text")
		.attr("transform", "translate(255,395)")
		.style("text-anchor","middle")
		.text("t-SNE 1")

var y_axis = d3.axisLeft()
           .scale(yScale_tsne);  

d3.select("#tsne").append("g")
	 	.attr("transform", "translate(40,0)")
		.call(y_axis);

d3.select("#tsne").append("text")
		.attr('transform', 'translate(15,190)rotate(-90)')
		.style("text-anchor","middle")
		.text("t-SNE 2")

// function for drawing t-sne
function draw_tsne(position, kmer_list) {
		
		var width = 500;
		var height = 400;
		//var padding = 65;
		
		d3.select('#tsne').remove()
		var svg = d3.select('.tsne')
				.append('svg')
				.attr("width", width)
        		.attr("height", height)
				.attr("id", "tsne")		

		var xScale = d3.scaleLinear()
				.domain(d3.extent(position, function(d) {return d[0];	}))	
				//.range([padding,width - padding * 2])	
				.range([40,width-20])
				.nice();

		var yScale = d3.scaleLinear()
				.domain(d3.extent(position, function(d) {return d[1]; }))
				//.range([height - padding, padding])
				//.range([20, height-40])
				.range([height-40, 20])
				.nice();

		var x_axis = d3.axisBottom()
                   .scale(xScale);  

		svg.append("g")
			 	.attr("transform", "translate(0,360)")
       			.call(x_axis);

		svg.append("text")
				.attr("transform", "translate(255,395)")
				.style("text-anchor","middle")
				.text("t-SNE 1")

		var y_axis = d3.axisLeft()
                   .scale(yScale);  

		svg.append("g")
			 	.attr("transform", "translate(40,0)")
       			.call(y_axis);

		svg.append("text")
				.attr('transform', 'translate(15,190)rotate(-90)')
				.style("text-anchor","middle")
				.text("t-SNE 2")

		var brush = d3.brush()
					//.extent([[0, 0], [100, 100]])
					//.on("brush", highlightBrushedCircles)
					//.on("end", endBrush)
					.on("brush", whileBrush);
		d3.select('#tsne').append("g")
				.call(brush)
				.call(brush.move)

		var old_color = null
		var circles = svg.append("g")
				.selectAll('circle')
			  .data(position)
			  .enter()
			  .append('circle')
				.attr('x', function(d) {
						return xScale(d[0]);
				})	
				.attr('y', function(d) {
						return yScale(d[1]);
				})
				.attr('r', 6)
				.attr('cx', function(d) {
						return xScale(d[0]);
				})
				.attr('cy', function(d) {
						return yScale(d[1]);
				})
				.attr("class", "non_brushed")
				.style('fill', function(d,i) { 
					if (kmer_list.length == 1) {
						return tsne_colors[0];
					
					} else if (kmer_list.length == 2) {	
						if (i < position.length/2) {
							return tsne_colors[0];
						} else {
							return tsne_colors[1];
						}
					} else if (kmer_list.length == 3) {
						if (i < position.length/3) {
							return tsne_colors[0];
						} else if(i >= position.length/3 && i < 2*position.length/3) {
							return tsne_colors[1];
						} else {
							return tsne_colors[2];
						}
					} else if (kmer_list.length == 4) {
							if (i < position.length/4) {
							return tsne_colors[0];
						} else if(i >= position.length/4 && i < 2*position.length/4) {
							return tsne_colors[1];
						} else if(i >= 2*position.length/4 && i < 3*position.length/4) {
							return tsne_colors[2];
						} else {
							return tsne_colors[3];
						}
					}
				})
				
				.on('click',function(d,i){
					if (d3.select(this).style("stroke") == "none") {
						d3.select(this).style("stroke", "black");
						d3.select(this).style("stroke-width", 2);
					}	else {
						d3.select(this).style("stroke", "none");
					}
					
					add_signal(i, kmer_list);
												
				})
				
				
				.on('mouseover', function(d,i){
					old_color = d3.select(this).style("fill")
					d3.select(this).attr("r", "10");
					d3.select(this).style("fill", "#ff0000")
					add_signal_hover(i, kmer_list);
				})
				.on('mouseout', function(d,i){
					d3.select(this).attr("r", "6");
					d3.select(this).style("fill", old_color)
					remove_signal_hover();
				})
				
		
		function highlightBrushedCircles() {
        if (d3.event.selection != null) {
           // revert circles to initial style
           circles.attr("class", "non_brushed");
           var brush_coords = d3.brushSelection(this);
           // style brushed circles
           circles.filter(function (){
           						var cx = d3.select(this).attr("cx"),
                          cy = d3.select(this).attr("cy");
                      return isBrushed(brush_coords, cx, cy);
                  })
                  .attr("class", "brushed");
					
         }
		}

		var lastBrushEvent = 0;

		function whileBrush() {
				// disregard brushes w/o selections				
				if (!d3.event.selection) return;
				// programmed clearing of brush after mouse-up
				//d3.select(this).call(brush.move, null);
				
			if (d3.event.selection != null) 
			{
				// revert circles to initial style
				circles.attr("class", "non_brushed");
				var brush_coords = d3.brushSelection(this);
				
				// style brushed circles
				circles.filter(function (){
					var cx = d3.select(this).attr("cx"),
					cy = d3.select(this).attr("cy");
					return isBrushed(brush_coords, cx, cy);
				})
				.attr("class", "brushed");
			}

			// get indices for the brushed points
			var d_brushed =  d3.selectAll(".brushed").data();			
			var row_list = []				
			if (d_brushed.length > 0 && row_list.length ==0) 
			{
				d_brushed.forEach(d_each => row_list.push(position.indexOf(d_each)))
			}
			
			(function(row_list, kmer_list, brushEvent) {
				setTimeout(function() 
				{
					if (brushEvent == lastBrushEvent) {
						add_signal_brush(row_list, kmer_list)
					}
					else
					{
						console.log("SAVED loading");
					}
				}, 2);

			})(row_list, kmer_list, ++lastBrushEvent)
		}		
}

function isBrushed(brush_coords, cx, cy) {
     var x0 = brush_coords[0][0],
         x1 = brush_coords[1][0],
         y0 = brush_coords[0][1],
         y1 = brush_coords[1][1];
	
      return x0 <= cx && cx <= x1 && y0 <= cy && cy <= y1;
}
// add new signals to data array and then pass it to draw_signal 
var data_click = []
var data_hover = []
var data_row = []
var data_brush = []
var data_export = []
function add_signal_brush(row_list, kmer_list, currentBrushEvent) {
	if (kmer_list.length == 1) {
		kmer1 = kmer_list[0]
		filename1 = folder+'/raw_signal/'+kmer1+'_signal.csv';
		
		(function(row_list, filename1, currentBrushEvent) {

			queue()
				.defer(
					d3.csv, filename1
					/*
					function(_callback) {
						setTimeout(function() 
						{
							if (currentBrushEvent == lastBrushEvent) {
								d3.csv(filename1, _callback); 
							}
							else
							{
								_callback(true);
							}
						}, 5);
					}
					*/
				)
				.await(add)
		
			function add(error, file1){
					if (error) { console.log("SAVED loading"); return; }
					d = file1
					if (data_brush.length >0){
							data_brush.length = 0
					}
					for (i=0;i<row_list.length;i++){
							row = row_list[i]
							data_brush.push(d[row]['values'].split("_").map(Number))
					}
					
					draw_signal(data_click, data_hover, data_brush)
			}
		})(row_list, filename1, currentBrushEvent);

	} else if (kmer_list.length == 2) {
		kmer1 = kmer_list[0]
		kmer2 = kmer_list[1]
		filename1 = folder+'/raw_signal/'+kmer1+'_signal.csv';
		filename2 = folder+'/raw_signal/'+kmer2+'_signal.csv';
		queue()
			.defer(d3.csv, filename1)
			.defer(d3.csv, filename2)
			.await(add)
	
		function add(error, file1, file2){
				d = file1.concat(file2)
				if (data_brush.length >0){
						data_brush.length = 0
				}
				for (i=0;i<row_list.length;i++){
						row = row_list[i]
						data_brush.push(d[row]['values'].split("_").map(Number))
				}
				
				draw_signal(data_click, data_hover, data_brush)
		}
	}	else if (kmer_list.length == 3) {
		kmer1 = kmer_list[0]
		kmer2 = kmer_list[1]
		kmer3 = kmer_list[2]
		filename1 = folder+'/raw_signal/'+kmer1+'_signal.csv';
		filename2 = folder+'/raw_signal/'+kmer2+'_signal.csv';
		filename3 = folder+'/raw_signal/'+kmer3+'_signal.csv';
		queue()
			.defer(d3.csv, filename1)
			.defer(d3.csv, filename2)
			.defer(d3.csv, filename3)
			.await(add)
	
		function add(error, file1, file2, file3){
				d = file1.concat(file2).concat(file3)
				if (data_brush.length >0){
						data_brush.length = 0
				}
				for (i=0;i<row_list.length;i++){
						row = row_list[i]
						data_brush.push(d[row]['values'].split("_").map(Number))
				}
				
				draw_signal(data_click, data_hover, data_brush)
		}
	}	else if (kmer_list.length == 4) {
		kmer1 = kmer_list[0]
		kmer2 = kmer_list[1]
		kmer3 = kmer_list[2]
		kmer4 = kmer_list[3]
		filename1 = folder+'/raw_signal/'+kmer1+'_signal.csv';
		filename2 = folder+'/raw_signal/'+kmer2+'_signal.csv';
		filename3 = folder+'/raw_signal/'+kmer3+'_signal.csv';
		filename4 = folder+'/raw_signal/'+kmer4+'_signal.csv';
		queue()
			.defer(d3.csv, filename1)
			.defer(d3.csv, filename2)
			.defer(d3.csv, filename3)
			.defer(d3.csv, filename4)
			.await(add)
	
		function add(error, file1, file2, file3, file4){
				d = file1.concat(file2).concat(file3).concat(file4)
				if (data_brush.length >0){
						data_brush.length = 0
				}
				for (i=0;i<row_list.length;i++){
						row = row_list[i]
						data_brush.push(d[row]['values'].split("_").map(Number))
				}
				
				draw_signal(data_click, data_hover, data_brush)
		}
	}	
}
function add_signal(row, kmer_list){
	if (kmer_list.length == 1) {
		kmer1 = kmer_list[0]
		filename1 = folder+'/raw_signal/'+kmer1+'_signal.csv';
		queue()
			.defer(d3.csv, filename1)
			.await(add)
		function add(error, file1){
				d = file1
				if (data_row.includes(row)) {
						index = data_row.indexOf(row)
						data_row.splice(index, 1)
						data_click.splice(index, 1)
						data_export.splice(index,1)
				} else {
						data_row.push(row)
						data_click.push(d[row]['values'].split("_").map(Number))
						data_export.push(d[row])		
				}
				
				draw_signal(data_click, data_hover, data_brush)
		}
	} else if (kmer_list.length == 2) {
		kmer1 = kmer_list[0]
		kmer2 = kmer_list[1]
		filename1 = folder+'/raw_signal/'+kmer1+'_signal.csv';
		filename2 = folder+'/raw_signal/'+kmer2+'_signal.csv';
		queue()
			.defer(d3.csv, filename1)
			.defer(d3.csv, filename2)
			.await(add)
		function add(error, file1, file2){
				d = file1.concat(file2)
				if (data_row.includes(row)) {
						index = data_row.indexOf(row)
						data_row.splice(index, 1)
						data_click.splice(index, 1)
						data_export.splice(index,1)
	
				} else {
						data_row.push(row)
						data_click.push(d[row]['values'].split("_").map(Number))		
						data_export.push(d[row])
				}
				
				draw_signal(data_click, data_hover, data_brush)
		}
	} else if (kmer_list.length == 3) {
		kmer1 = kmer_list[0]
		kmer2 = kmer_list[1]
		kmer3 = kmer_list[2]
		filename1 = folder+'/raw_signal/'+kmer1+'_signal.csv';
		filename2 = folder+'/raw_signal/'+kmer2+'_signal.csv';
		filename3 = folder+'/raw_signal/'+kmer3+'_signal.csv';
		queue()
			.defer(d3.csv, filename1)
			.defer(d3.csv, filename2)
			.defer(d3.csv, filename3)
			.await(add)
		function add(error, file1, file2, file3){
				d = file1.concat(file2).concat(file3)
				if (data_row.includes(row)) {
						index = data_row.indexOf(row)
						data_row.splice(index, 1)
						data_click.splice(index, 1)
						data_export.splice(index,1)
				} else {
						data_row.push(row)
						data_click.push(d[row]['values'].split("_").map(Number))		
						data_export.push(d[row])
				}
				
				draw_signal(data_click, data_hover, data_brush)
		}
	} else if (kmer_list.length == 4) {
		kmer1 = kmer_list[0]
		kmer2 = kmer_list[1]
		kmer3 = kmer_list[2]
		kmer4 = kmer_list[3]
		filename1 = folder+'/raw_signal/'+kmer1+'_signal.csv';
		filename2 = folder+'/raw_signal/'+kmer2+'_signal.csv';
		filename3 = folder+'/raw_signal/'+kmer3+'_signal.csv';
		filename4 = folder+'/raw_signal/'+kmer4+'_signal.csv';
		queue()
			.defer(d3.csv, filename1)
			.defer(d3.csv, filename2)
			.defer(d3.csv, filename3)
			.defer(d3.csv, filename4)
			.await(add)
		function add(error, file1, file2, file3, file4){
				d = file1.concat(file2).concat(file3).concat(file4)
				if (data_row.includes(row)) {
						index = data_row.indexOf(row)
						data_row.splice(index, 1)
						data_click.splice(index, 1)
						data_export.splice(index,1)
				} else {
						data_row.push(row)
						data_click.push(d[row]['values'].split("_").map(Number))
						data_export.push(d[row])		
				}
				
				draw_signal(data_click, data_hover, data_brush)
		}
	}
	
}
var signalToAdd = null;
function add_signal_hover(row, kmer_list){
	if (kmer_list.length == 1) {
		kmer1 = kmer_list[0]
		filename1 = folder+'/raw_signal/'+kmer1+'_signal.csv';
		queue()	
			.defer(d3.csv, filename1)
			.await(add)
		current_kmer = kmer1
		signalToAdd = current_kmer + '_' + row;
		function add(error, file1){
				d = file1
						d3.selectAll('.line_hover').remove();
						if (signalToAdd == current_kmer + '_' + row)
						{
							data_hover.push(d[row]['values'].split("_").map(Number))
							draw_signal(data_click, data_hover, data_brush)
							
						}
	
		}
	}	else if (kmer_list.length == 2) {
		kmer1 = kmer_list[0]
		kmer2 = kmer_list[1]
		filename1 = folder+'/raw_signal/'+kmer1+'_signal.csv';
		filename2 = folder+'/raw_signal/'+kmer2+'_signal.csv';
		queue()	
			.defer(d3.csv, filename1)
			.defer(d3.csv, filename2)
			.await(add)
		current_kmer = kmer1+'_'+kmer2
		signalToAdd = current_kmer + '_' + row;
		function add(error, file1, file2){
			d = file1.concat(file2)
			d3.selectAll('.line_hover').remove();
			if (signalToAdd == current_kmer + '_' + row)
			{
				data_hover.push(d[row]['values'].split("_").map(Number))
				draw_signal(data_click, data_hover, data_brush)
			}
		}
	} else if (kmer_list.length == 3) {
		kmer1 = kmer_list[0]
		kmer2 = kmer_list[1]
		kmer3 = kmer_list[2]
		filename1 = folder+'/raw_signal/'+kmer1+'_signal.csv';
		filename2 = folder+'/raw_signal/'+kmer2+'_signal.csv';
		filename3 = folder+'/raw_signal/'+kmer3+'_signal.csv';
		queue()	
			.defer(d3.csv, filename1)
			.defer(d3.csv, filename2)
			.defer(d3.csv, filename3)
			.await(add)
		current_kmer = kmer1+'_'+kmer2+'_'+kmer3
		signalToAdd = current_kmer + '_' + row;
		function add(error, file1, file2, file3){
				d = file1.concat(file2).concat(file3)
						d3.selectAll('.line_hover').remove();
						if (signalToAdd == current_kmer + '_' + row)
						{
							data_hover.push(d[row]['values'].split("_").map(Number))
							draw_signal(data_click, data_hover, data_brush)
						}
		}
	} else if (kmer_list.length == 4) {
		kmer1 = kmer_list[0]
		kmer2 = kmer_list[1]
		kmer3 = kmer_list[2]
		kmer4 = kmer_list[3]
		
		filename1 = folder+'/raw_signal/'+kmer1+'_signal.csv';
		filename2 = folder+'/raw_signal/'+kmer2+'_signal.csv';
		filename3 = folder+'/raw_signal/'+kmer3+'_signal.csv';
		filename4 = folder+'/raw_signal/'+kmer4+'_signal.csv';
		queue()	
			.defer(d3.csv, filename1)
			.defer(d3.csv, filename2)
			.defer(d3.csv, filename3)
			.defer(d3.csv, filename4)
			.await(add)
		current_kmer = kmer1+'_'+kmer2+'_'+kmer3+'_'+kmer4
		signalToAdd = current_kmer + '_' + row;
		function add(error, file1, file2, file3, file4){
				d = file1.concat(file2).concat(file3).concat(file4)
						d3.selectAll('.line_hover').remove();
						if (signalToAdd == current_kmer + '_' + row)
						{
							data_hover.push(d[row]['values'].split("_").map(Number))
							draw_signal(data_click, data_hover, data_brush)
						}
		}
	}
}
function remove_signal_hover(){
	
	data_hover = []
	d3.selectAll('.line_hover').remove();
	signalToAdd=null;
}

var div = d3.select("body").append("div")	
    .attr("class", "tooltip")				
    .style("opacity", 0);

box_colors = ["rgb(51, 160, 44)","rgb(31, 120, 180)","rgb(0, 0, 0)","rgb(255, 127, 0)"]  //reset when changing sort type

kmer_list = []
function draw_boxplot(data, form_val) {
		
	if (form_val == 'sort_median') {
		data.sort(function(a,b) {
			return b['median'] - a['median'];
		});
	} else if (form_val == 'sort_kmer') {
		data.sort(function(a,b) {
			var x = a['kmer'].toLowerCase();
			var y = b['kmer'].toLowerCase();
			return x < y ? -1 : x > y ? 1 : 0;
		});
	} else if (form_val == 'sort_max') {
		data.sort(function(a,b) {
			return b['max'] - a['max'];
		});
	}
		
	var w = 580
	var h = 7500*data.length /256
	var margin = {
	    top: 20,
	    bottom: 20,
	    left: 20,
	    right: 30
  	}

	d3.select('.viewport')
    	.append('svg')
		    .attr('height', h)
		    .attr('width', w)
		    //.attr("transform","translate(" + margin.left + "," + margin.top + ")");


	var catVariable = 'order'
	var catValues = data.map(d => Number(d[catVariable]))
	var kmerValues = data.map(d => d['kmer'])
	const minVariable = 'min'
    const maxVariable = 'max'
    const medianVariable = 'median'
    const q1Variable = 'q1'
    const q3Variable = 'q3'

	var xScale = d3.scaleLinear()
		.domain([0,8000])
		.range([margin.left, w- margin.right-50])
	
	
	var yScale = d3.scalePoint()
			.domain(kmerValues)
			.range([margin.top,h - margin.bottom])
	
	var yAxis = d3.axisRight()
					.scale(yScale)
					.tickSize(0)

				//.tickValues(catValues)
					//.tickValues(kmerValues)
								
	d3.select('svg')
		.append('g')
			.style("font", "14px times")
			.attr('transform', 'translate(0,0)')
			.attr('id', 'yAxisG')
			.call(yAxis)

	var previous_color = null
    var previous_opacity = null

	d3.select('svg')
		.selectAll('g.box')
		.data(data)
		.enter()		
		.append('g')
		.attr('class', 'box')
		.attr(
		//	'transform', d => `translate(${xScale(d[medianVariable])},${yScale(d['kmer'])})`
			'transform', d => `translate(${100},${yScale(d['kmer'])})`
		)
		
		.each(function(d, i) {
			d3.select(this)
		        .append('rect')
		        .attr('class', 'cover')
		        .attr('id', d['kmer']+'_box')
		        .attr('x', -100)
		        .attr('y', -15)
		        .attr('height', 30)
		        .attr('width', 480)
		        .style('fill', 'white')
		        .style('stroke', 'black')
		        .style('stroke-width', '1px')
				.style('opacity', 0)
				.on("click", function(d) {
					
					if(kmer_list.length < 4 && kmer_list.includes(d.kmer)==false) {				
					
						d3.select('#tsne').selectAll('circle').remove()	
						loading_gif()
						
						d3.select(this).style("opacity",0.3)
						d3.select(this).style("stroke",'none')
						d3.select(this).style("fill",box_colors[box_colors.length-1])
						tsne_colors.push(box_colors[box_colors.length-1])	
						box_colors.pop()
						
						// remove selected boxplot from the current viewport
						index = kmerValues.indexOf(d.kmer)
						kmerValues.splice(index, 1)
						/*
						filtered_data = []
						for (i=0;i<data.length;i++) {
							if(kmerValues.includes(data[i]['kmer']) ){
								filtered_data.push(data[i])
							}
						}
						*/

						// get sorting option
						var form = document.getElementById("sort")
						var form_val;
						for(var i=0; i<form.length; i++){
	      	  				if(form[i].checked){
	      	    				form_val = form[i].id;
							}
						}

						//d3.select(".viewport").selectAll("*").remove()
						kmer_list.push(d.kmer)
						//draw_boxplot(filtered_data, form_val)						
						draw_clicked_boxplot(kmer_list, tsne_colors)
							
						if (kmer_list.length == 1) {
								combine_1_kmer(kmer_list)
						} else if (kmer_list.length == 2) {
								combine_2_kmers(kmer_list)
						} else if (kmer_list.length == 3) {
								combine_3_kmers(kmer_list)
						} else if (kmer_list.length == 4) {
								combine_4_kmers(kmer_list)
						} else{
								d3.select('#tsne').selectAll('circle').remove()
						}
					
					previous_color = d3.select(this).style('fill')
					previous_opacity = d3.select(this).style('opacity')
					}
        		})

        		
				.on('mouseover', function(){
					previous_color = d3.select(this).style('fill')
					previous_opacity = d3.select(this).style('opacity')
					d3.select(this)
						.style('fill', 'grey')
				        .style('stroke', 'none')
						.style('opacity', 0.4)
				})
				.on('mouseout', function(){
					d3.select(this)
						.style('fill', previous_color)
						.style('opacity', previous_opacity)
				})

			d3.select(this)
				.append('line')
					.attr('class', 'range')
					.attr('x1', xScale(d[maxVariable]) - xScale(d[medianVariable]))
			        .attr('x2', xScale(d[minVariable]) - xScale(d[medianVariable]))
			        .attr('y1', 0)
			        .attr('y2', 0)
			        .style('stroke', 'black')
			        .style('stroke-width', '2px')
			d3.select(this)
		        .append('line')
			        .attr('class', 'max')
			        .attr('x1', xScale(d[maxVariable]) - xScale(d[medianVariable]))
			        .attr('x2', xScale(d[maxVariable]) - xScale(d[medianVariable]))
			        .attr('y1', -8)
			        .attr('y2', 8)
			        .style('stroke', 'black')
			        .style('stroke-width', '2px')			
			d3.select(this)
				.append('line')
			        .attr('class', 'min')
			        .attr('x1', xScale(d[minVariable]) - xScale(d[medianVariable]))
			        .attr('x2', xScale(d[minVariable]) - xScale(d[medianVariable]))
			        .attr('y1', -8)
			        .attr('y2', 8)
			        .style('stroke', 'black')
			        .style('stroke-width', '2px')
			d3.select(this)
        		.append('rect')
			        .attr('class', 'range')
			        .attr('x', xScale(d[q1Variable]) - xScale(d[medianVariable]))
			        .attr('y', -8)
			        .attr('height', 16)
			        .attr('width', xScale(d[q3Variable]) - xScale(d[q1Variable]))
			        .style('fill', 'white')
			        .style('stroke', 'black')
			        .style('stroke-width', '2px')
				.on("mouseover", function(d) {
            div.transition()		
                .duration(200)		
                .style("opacity", 1);		
            div	.html('<strong>'+'median : '+'</strong>'+ d3.format(",.0f")(d.median) + "<br/>" +'<strong>'+'max : '+'</strong>'+d3.format(",.0f")(d.max) + "<br/>"  + '<strong>'+'min : '+'</strong>'+d3.format(",.0f")(d.min))	
                .style("left", (d3.event.pageX) + "px")		
                .style("top", (d3.event.pageY - 28) + "px");
						d3.select(this).style('fill', '#ff0000')			
     				})
		.on("mouseout", function(d) {		
            div.transition()		
                .duration(500)		
                .style("opacity", 0);
			d3.select(this).style('fill', 'white')	
        })
			d3.select(this)
		        .append('line')
			        .attr('x1', 0)
			        .attr('x2', 0)
			        .attr('y1', -8)
			        .attr('y2', 8)
			        .style('stroke', '#852121')
			        .style('stroke-width', '4px')
		})

	for (i = 0; i<kmer_list.length; i++) {
		d3.select('#'+kmer_list[i]+'_box').style('fill', tsne_colors[i])
		d3.select('#'+kmer_list[i]+'_box').style('opacity', 0.3)
		d3.select('#'+kmer_list[i]+'_box').style('stroke', 'none')
	}
}

function loading_gif(){
	d3.select("#tsne")
		.append("svg:image")
		    .attr('x', 220)
		    .attr('y',130)
		    .attr('width', 100)
		    .attr('height', 140)
		    .attr("xlink:href", "./images/ajax-loader.gif")
}


// for selected kmers
function draw_clicked_boxplot(clicked_kmers, clicked_colors){
	
	d3.select('.viewport_selected').selectAll('*').remove()
	d3.csv(folder+'/boxplot_data.csv', function(data) {
		all_data = data
		clicked_data = []
		for (i=0;i<256;i++) {
			if(clicked_kmers.includes(data[i]['kmer']) ){
				clicked_data.push(data[i])
			}
		}

		data = clicked_data
		kmerValues = clicked_kmers
		var w = 350
		var h = 7500*clicked_data.length /256
		var margin = {
		    top: 20,
		    bottom: 20,
		    left: 20,
		    right: 30
		 }

		d3.select('.viewport_selected')
		    .append('svg')
		    .attr('height', h)
		    .attr('width', w)

		var catVariable = 'order'
		var catValues = data.map(d => Number(d[catVariable]))
		var kmerValues = data.map(d => d['kmer'])
		const minVariable = 'min'
	    const maxVariable = 'max'
	    const medianVariable = 'median'
	    const q1Variable = 'q1'
	    const q3Variable = 'q3'
		var xScale = d3.scaleLinear()
				.domain([0,8000])
				.range([margin.left, w- margin.right-50])
		/*var yScale = d3.scaleLinear()
				.domain([
					Number(d3.max(data, d => d[catVariable])) + 1,
					Number(d3.min(data, d => d[catVariable])) - 1
				])
				.range([h - margin.bottom, margin.top])	
	  */
	
		var yScale = d3.scalePoint()
				.domain(kmerValues)
				.range([margin.top,h - margin.bottom])
		/*var xAxis = d3.axisBottom()
									.scale(xScale)
									.ticks(10)
									.tickSize(-470) 
					
		d3.select('svg')
			.append('g')
			.attr('transform', 'translate(0,480)')
			.attr('id', 'xAxisG')
			.call(xAxis) */
		var yAxis = d3.axisRight()
						.scale(yScale)
						.tickSize(0)
					//.tickValues(catValues)
						//.tickValues(kmerValues)
								
	
	d3.select('.viewport_selected').select('svg')
		.append('g')
		.attr('transform', 'translate(300,0)')
		.attr('id', 'yAxisG')
		.call(yAxis)
	d3.select('.viewport_selected').select('svg')
		.selectAll('g.box')
		.data(data)
		.enter()
		.append('g')
		.attr('class', 'box')
		.attr(
			'transform', d => `translate(${xScale(d[medianVariable])},${yScale(d['kmer'])})`
		)
		
		.each(function(d, i) {
			d3.select(this)
		        .append('rect')
		        //.attr('class', 'cover')
		        .attr('x', xScale(d[minVariable]) - xScale(d[medianVariable]))
		        .attr('y', -10)
		        .attr('height', 20)
		        .attr('width', 480)
		        .style('fill', clicked_colors[i])
		        .style('stroke', 'none')
		        .style('stroke-width', '1px')
				.style('opacity', 0.3)
				.on("click", function(d) {
					box_colors.push(d3.select(this).style("fill"))
					tsne_colors.splice(tsne_colors.indexOf(d3.select(this).style("fill")),1)
					index = kmer_list.indexOf(d.kmer)
					kmer_list.splice(index, 1)

					// remove color from the all-kmer panel
					clicked_id = d.kmer+'_box'
					d3.select('#'+clicked_id).style('fill','white')
					d3.select('#'+clicked_id).style('opacity',0)
					
					// redraw clicked boxplot
					draw_clicked_boxplot(kmer_list, tsne_colors)
					
					// redraw t-SNE
					if (kmer_list.length == 1) {
							combine_1_kmer(kmer_list)
					} else if (kmer_list.length == 2) {
							combine_2_kmers(kmer_list)
					} else if (kmer_list.length == 3) {
							combine_3_kmers(kmer_list)
					} else if (kmer_list.length == 4) {
							combine_4_kmers(kmer_list)
					} else{
							d3.select('#tsne').selectAll('circle').remove()
					}
			
				})

			d3.select(this)
				.append('line')
					.attr('class', 'range')
					.attr('x1', xScale(d[maxVariable]) - xScale(d[medianVariable]))
			        .attr('x2', xScale(d[minVariable]) - xScale(d[medianVariable]))
			        .attr('y1', 0)
			        .attr('y2', 0)
			        .style('stroke', 'black')
			        .style('stroke-width', '2px')

			d3.select(this)
		        .append('line')
			        .attr('class', 'max')
			        .attr('x1', xScale(d[maxVariable]) - xScale(d[medianVariable]))
			        .attr('x2', xScale(d[maxVariable]) - xScale(d[medianVariable]))
			        .attr('y1', -10)
			        .attr('y2', 10)
			        .style('stroke', 'black')
			        .style('stroke-width', '2px')	

			d3.select(this)
				.append('line')
			        .attr('class', 'min')
			        .attr('x1', xScale(d[minVariable]) - xScale(d[medianVariable]))
			        .attr('x2', xScale(d[minVariable]) - xScale(d[medianVariable]))
			        .attr('y1', -10)
			        .attr('y2', 10)
			        .style('stroke', 'black')
			        .style('stroke-width', '2px')

			d3.select(this)
		        .append('rect')
			        .attr('class', 'range')
			        .attr('x', xScale(d[q1Variable]) - xScale(d[medianVariable]))
			        .attr('y', -10)
			        .attr('height', 20)
			        .attr('width', xScale(d[q3Variable]) - xScale(d[q1Variable]))
			        .style('fill', 'white')
			        .style('stroke', 'black')
			        .style('stroke-width', '2px')
					.on("mouseover", function(d) {
			            div.transition()		
			                .duration(200)		
			                .style("opacity", 1);		
			            div	.html('<strong>'+'median : '+'</strong>'+ d3.format(",.0f")(d.median) + "<br/>" +'<strong>'+'max : '+'</strong>'+d3.format(",.0f")(d.max) + "<br/>"  + '<strong>'+'min : '+'</strong>'+d3.format(",.0f")(d.min))	
			                .style("left", (d3.event.pageX) + "px")		
			                .style("top", (d3.event.pageY - 28) + "px");
									d3.select(this).style('fill', '#ff0000')			
	     			})

					.on("mouseout", function(d) {		
			            div.transition()		
			                .duration(500)		
			                .style("opacity", 0);
							d3.select(this).style('fill', 'white')	
			        })

			d3.select(this)
		        .append('line')
			        .attr('x1', 0)
			        .attr('x2', 0)
			        .attr('y1', -10)
			        .attr('y2', 10)
			        .style('stroke', 'darkgray')
			        .style('stroke-width', '4px')
		})
	})
}

// a function to download a csv file, given an array of arrays (array_export)
function download_csv() {
							
    var csv = 'kmer,read_ID,values\n';
    array_export.forEach(function(row) {
	    csv += row.join(',');
	    csv += "\n";
    });

	var hiddenElement = document.createElement('a');
	hiddenElement.href = 'data:text/csv;charset=utf-8,' + encodeURI(csv);
	hiddenElement.target = '_blank';
	hiddenElement.download = 'data.csv';
	hiddenElement.click();
}		


// initialize raw signal plot on landing page
var signal_init = {
	m : [20, 40, 20, 90], // margins
	w : 800 - 40 - 90, // width
	h : 270 - 20 - 20 // height
}
var graph_signal = d3.select(".raw_signal").append("svg:svg")
		.attr("width", signal_init.w + signal_init.m[1] + signal_init.m[3])
		.attr("height", signal_init.h + signal_init.m[0] + signal_init.m[2])
		.attr("id", "signal")
	.append("svg:g")
		.attr("transform", "translate(" + signal_init.m[1] + "," + signal_init.m[0] + ")")
	
	var xScale_signal = d3.scaleLinear()
						.domain([0, 260]) //set max value to fix the x-axis
						.range([0, signal_init.w]);

	 var yScale_signal = d3.scaleLinear().domain([0, 0]).range([signal_init.h, 0]); 

	// create xAxis
	var xAxis_signal = d3.axisBottom()
				.scale(xScale_signal)
				.tickSize(-signal_init.h)
				//.tickSubdivide(true);
	// Add the x-axis.
	graph_signal.append("svg:g")
			.attr("class", "x axis")
			.attr("transform", "translate(0," + signal_init.h + ")")
			.call(xAxis_signal);
	graph_signal.append("text")
			.attr("transform", "translate(730,235)")
			.style("text-anchor","middle")
			.text("time (ms)")

	// create yaxis
	var yAxis_signal = d3.axisLeft()
			.scale(yScale_signal)
	
	graph_signal.append("svg:g")
			.attr("class", "y axis")
			.attr("transform", "translate(0,0)")
			.call(yAxis_signal);		

	graph_signal.append("text")
			.attr("transform", "translate(12,-5)")
			.style("text-anchor","middle")
			.text("current (mA)")

var array_export 

// draw raw signals based on the data passed from add_signal
function draw_signal(data_click,data_hover, data_brush) {
			 // preparing for download_csv() by converting an array of objects(data_export) to an array of arrays(array_export)
			 array_export = data_export.map(function(obj) {
				return Object.keys(obj).sort().map(function(key) { 
				return obj[key];
				});
			});

			var data = data_hover.concat(data_click).concat(data_brush)
			
			var m = [20, 40, 20, 90]; // margins
        	var w = 800 - m[1] - m[3]; // width
        	var h = 270 - m[0] - m[2]; // height
        	 
        	
        	// X scale will fit all values from data[] within pixels 0-w
        	/*var x_max = 0;
        	for (var i = data_brush.length - 1; i >= 0; i--) {
        	    if (data_brush[i].length > x_max) x_max = data_brush[i].length;
        	};*/
        	var x = d3.scaleLinear()
						.domain([0, 260]) //set max value to fix the x-axis
						.range([0, w]);
        	// Y scale will fit values from 0-10 within pixels h-0 (Note the inverted domain for the y-scale: bigger is up!)
        	
					var min = 999999;
					var max = 0;
					for (var i = data.length - 1; i >= 0; i--) {
        	    if(Math.max.apply(Math, data[i]) > max) max = Math.max.apply(Math, data[i])
							if(Math.min.apply(Math, data[i]) < min) min = Math.min.apply(Math, data[i])
        	};
					
        	var y = d3.scaleLinear().domain([min, max]).range([h, 0]); 
					
        	// automatically determining max range can work something like this
        	//var y = d3.scaleLinear().domain([0, d3.max(data_hover[0])]).range([h, 0]);
        	// create a line function that can convert data[] into x and y points
        	var line = d3.line()
        	// assign the X function to plot our line as we wish
        	.x(function(d, i) {
        	    
        	    // return the X coordinate where we want to plot this datapoint
        	    return x(i);
        	}).y(function(d) {
        	    
        	    // return the Y coordinate where we want to plot this datapoint
        	    return y(d);
        	})
        	// Add an SVG element with the desired dimensions and margin.
			d3.select(".raw_signal").selectAll('*').remove()
        	var graph = d3.select(".raw_signal")
						.append("svg:svg")
							.attr("width", w + m[1] + m[3])
							.attr("height", h + m[0] + m[2])
							.attr("id", "signal")
						.append("svg:g")
							.attr("transform", "translate(" + m[1] + "," + m[0] + ")")
						
        	// create xAxis
        	var xAxis = d3.axisBottom()
						.scale(x)
						.tickSize(-h)
						//.tickSubdivide(true);
        	// Add the x-axis.
        	graph.append("svg:g")
					.attr("class", "x axis")
					.attr("transform", "translate(0," + h + ")")
					.call(xAxis);
        	graph.append("text")
					.attr("transform", "translate(730,235)")
					.style("text-anchor","middle")
					.text("time (ms)")


			// create yaxis
			var yAxis = d3.axisLeft()
					.scale(y)
			
			graph.append("svg:g")
					.attr("class", "y axis")
					.attr("transform", "translate(0,0)")
					.call(yAxis);		

			graph.append("text")
					.attr("transform", "translate(12,-5)")
					.style("text-anchor","middle")
					.text("current (mA)")

					// add lines
        	// do this AFTER the axes above so that the line is above the tick-lines
					// signal plots for the clicked points
        	for (var i = data_click.length - 1; i >= 0; i--) {
        	    graph.append("svg:path")
						.attr("d", line(data_click[i]))
						.attr("class","line_click")
						.on("mouseover",function(d){d3.select(this).style("stroke-width",3)})
						.on("mouseout",function(d){d3.select(this).style("stroke-width",1)})
			};  
					
			// signal plot for the hovered point				
			/*for (var i = data_hover.length - 1; i >= 0; i--) {
				graph.append("svg:path")
						.attr("d", line(data_hover[i]))
						.attr("class","line_hover")
						.attr('transform', function(d) {
   	    						if (d3.select("#normalize_checkbox").property("checked")) {
   	    							return 'scale(' + (1/(d.length/260)) + ' 1)';
   	    						}
   	    						else {
   	    							return null;
   	    						}
   	    					})
   	    					.attr('vector-effect', 'non-scaling-stroke')
			};*/
			
			graph.selectAll(".line")
				.data(data_hover)
				.enter().append("svg:path")
							.attr("d", line)
							.attr("class","line_hover")
							.attr('transform', function(d) {
   	    						if (d3.select("#normalize_checkbox").property("checked")) {
   	    							return 'scale(' + (1/(d.length/260)) + ' 1)';
   	    						}
   	    						else {
   	    							return null;
   	    						}
   	    					})
   	    					.attr('vector-effect', 'non-scaling-stroke')	
					
			// signal plots for the brushed points
			
			graph.selectAll(".line")
				.data(data_brush)
				.enter().append("svg:path")
							.attr("d", line)
							.attr("class", "line_brush")
							.attr('transform', function(d) {
   	    						if (d3.select("#normalize_checkbox").property("checked")) {
   	    							return 'scale(' + (1/(d.length/260)) + ' 1)';
   	    						}
   	    						else {
   	    							return null;
   	    						}
   	    					})
   	    					.attr('vector-effect', 'non-scaling-stroke')
   	    					.attr("id", function(d,i){return "line_brush_"+d; })  
							.on("mouseover",function(d){d3.select(this).style("stroke-width",3)})
							.on("mouseout",function(d){d3.select(this).style("stroke-width",1)})

			putNodeOnTop(d3.select(".line_hover").node());
}

function putNodeOnTop(node) {
   var n = jQuery(node);
   n.parent().append(n.detach());
}


function combine_1_kmer(kmer_list){
		kmer1 = kmer_list[0]
		
		folder1 = folder+'/distance_matrices/'+kmer1
		
		queue()
		.defer(d3.csv, folder1 + '/' + kmer1 + '_' + kmer1 + '.csv')
		.await(combine_csv)
	function combine_csv(error, file1) {
		if(error) {console.log(error);}
		
		// Convert array of objects to array of arrays
		file1 = file1.map(obj => Object.values(obj));
		
		// call update_tsne
		update_tsne(file1, kmer_list)
	}
}

function combine_2_kmers(kmer_list){
		kmer1 = kmer_list[0]
		kmer2 = kmer_list[1]
		folder1 = folder+'/distance_matrices/'+kmer1
		folder2 = folder+'/distance_matrices/'+kmer2
		queue()
			.defer(d3.csv, folder1 + '/' + kmer1 + '_' + kmer1 + '.csv')
			.defer(d3.csv, folder1 + '/' + kmer1 + '_' + kmer2 + '.csv')
			.defer(d3.csv, folder2 + '/' + kmer2 + '_' + kmer1 + '.csv')
			.defer(d3.csv, folder2 + '/' + kmer2 + '_' + kmer2 + '.csv')
			.await(combine_csv)
	function combine_csv(error, file1, file2, file3, file4) {
		if(error) {console.log(error);}
		
		// Convert array of objects to array of arrays
		file1 = file1.map(obj => Object.values(obj));
		file2 = file2.map(obj => Object.values(obj));
		file3 = file3.map(obj => Object.values(obj));
		file4 = file4.map(obj => Object.values(obj));
		
		// column concat
		kmer1_row = file1.map((value,index) => { return value.concat(file2[index]) });
		kmer2_row = file3.map((value,index) => { return value.concat(file4[index]) });
		// row concat
		combined_matrix = kmer1_row.concat(kmer2_row)
		
		// call update_tsne
		update_tsne(combined_matrix, kmer_list)
	}
}

function combine_3_kmers(kmer_list){
		kmer1 = kmer_list[0]
		kmer2 = kmer_list[1]
		kmer3 = kmer_list[2]
		folder1 = folder+'/distance_matrices/'+kmer1
		folder2 = folder+'/distance_matrices/'+kmer2
		folder3 = folder+'/distance_matrices/'+kmer3
		queue()
			.defer(d3.csv, folder1 + '/' + kmer1 + '_' + kmer1 + '.csv')
			.defer(d3.csv, folder1 + '/' + kmer1 + '_' + kmer2 + '.csv')
			.defer(d3.csv, folder1 + '/' + kmer1 + '_' + kmer3 + '.csv')
			.defer(d3.csv, folder2 + '/' + kmer2 + '_' + kmer1 + '.csv')
			.defer(d3.csv, folder2 + '/' + kmer2 + '_' + kmer2 + '.csv')
			.defer(d3.csv, folder2 + '/' + kmer2 + '_' + kmer3 + '.csv')
			.defer(d3.csv, folder3 + '/' + kmer3 + '_' + kmer1 + '.csv')
			.defer(d3.csv, folder3 + '/' + kmer3 + '_' + kmer2 + '.csv')
			.defer(d3.csv, folder3 + '/' + kmer3 + '_' + kmer3 + '.csv')
			.await(combine_csv)
	function combine_csv(error, file1, file2, file3, file4, file5, file6, file7, file8, file9) {
		if(error) {console.log(error);}
		
		// Convert array of objects to array of arrays
		file1 = file1.map(obj => Object.values(obj));
		file2 = file2.map(obj => Object.values(obj));
		file3 = file3.map(obj => Object.values(obj));
		file4 = file4.map(obj => Object.values(obj));
		file5 = file5.map(obj => Object.values(obj));
		file6 = file6.map(obj => Object.values(obj));
		file7 = file7.map(obj => Object.values(obj));
		file8 = file8.map(obj => Object.values(obj));
		file9 = file9.map(obj => Object.values(obj));
		
		// column concat
		kmer1_row = file1.map((value,index) => { return value.concat(file2[index]).concat(file3[index]) });
		kmer2_row = file4.map((value,index) => { return value.concat(file5[index]).concat(file6[index]) });
		kmer3_row = file7.map((value,index) => { return value.concat(file8[index]).concat(file9[index]) });
		// row concat
		combined_matrix = kmer1_row.concat(kmer2_row).concat(kmer3_row)
				
		// call update_tsne
		update_tsne(combined_matrix, kmer_list)
	}
}
function combine_4_kmers(kmer_list){
		kmer1 = kmer_list[0]
		kmer2 = kmer_list[1]
		kmer3 = kmer_list[2]
		kmer4 = kmer_list[3]
		folder1 = folder+'/distance_matrices/'+kmer1
		folder2 = folder+'/distance_matrices/'+kmer2
		folder3 = folder+'/distance_matrices/'+kmer3
		folder4 = folder+'/distance_matrices/'+kmer4
		queue()
			.defer(d3.csv, folder1 + '/' + kmer1 + '_' + kmer1 + '.csv')
			.defer(d3.csv, folder1 + '/' + kmer1 + '_' + kmer2 + '.csv')
			.defer(d3.csv, folder1 + '/' + kmer1 + '_' + kmer3 + '.csv')
			.defer(d3.csv, folder1 + '/' + kmer1 + '_' + kmer4 + '.csv')
			.defer(d3.csv, folder2 + '/' + kmer2 + '_' + kmer1 + '.csv')
			.defer(d3.csv, folder2 + '/' + kmer2 + '_' + kmer2 + '.csv')
			.defer(d3.csv, folder2 + '/' + kmer2 + '_' + kmer3 + '.csv')
			.defer(d3.csv, folder2 + '/' + kmer2 + '_' + kmer4 + '.csv')
			.defer(d3.csv, folder3 + '/' + kmer3 + '_' + kmer1 + '.csv')
			.defer(d3.csv, folder3 + '/' + kmer3 + '_' + kmer2 + '.csv')
			.defer(d3.csv, folder3 + '/' + kmer3 + '_' + kmer3 + '.csv')
			.defer(d3.csv, folder3 + '/' + kmer3 + '_' + kmer4 + '.csv')
			.defer(d3.csv, folder4 + '/' + kmer4 + '_' + kmer1 + '.csv')
			.defer(d3.csv, folder4 + '/' + kmer4 + '_' + kmer2 + '.csv')
			.defer(d3.csv, folder4 + '/' + kmer4 + '_' + kmer3 + '.csv')
			.defer(d3.csv, folder4 + '/' + kmer4 + '_' + kmer4 + '.csv')
			.await(combine_csv)
	function combine_csv(error, file1, file2, file3, file4, file5, file6, file7, file8, file9, file10, file11, file12, file13, file14, file15, file16) {
		if(error) {console.log(error);}
		
		// Convert array of objects to array of arrays
		file1 = file1.map(obj => Object.values(obj));
		file2 = file2.map(obj => Object.values(obj));
		file3 = file3.map(obj => Object.values(obj));
		file4 = file4.map(obj => Object.values(obj));
		file5 = file5.map(obj => Object.values(obj));
		file6 = file6.map(obj => Object.values(obj));
		file7 = file7.map(obj => Object.values(obj));
		file8 = file8.map(obj => Object.values(obj));
		file9 = file9.map(obj => Object.values(obj));
		file10 = file10.map(obj => Object.values(obj));
		file11 = file11.map(obj => Object.values(obj));
		file12 = file12.map(obj => Object.values(obj));
		file13 = file13.map(obj => Object.values(obj));
		file14 = file14.map(obj => Object.values(obj));
		file15 = file15.map(obj => Object.values(obj));
		file16 = file16.map(obj => Object.values(obj));
		
		
		// column concat
		kmer1_row = file1.map((value,index) => { return value.concat(file2[index]).concat(file3[index]).concat(file4[index]) });
		kmer2_row = file5.map((value,index) => { return value.concat(file6[index]).concat(file7[index]).concat(file8[index]) });
		kmer3_row = file9.map((value,index) => { return value.concat(file10[index]).concat(file11[index]).concat(file12[index]) });
		kmer4_row = file13.map((value,index) => { return value.concat(file14[index]).concat(file15[index]).concat(file16[index]) });
		// row concat
		combined_matrix = kmer1_row.concat(kmer2_row).concat(kmer3_row).concat(kmer4_row)
				
		// call update_tsne
		update_tsne(combined_matrix, kmer_list)
	}
}

var opts = {
  lines: 9, // The number of lines to draw
  length: 9, // The length of each line
  width: 5, // The line thickness
  radius: 14, // The radius of the inner circle
  color: '#EE3124', // #rgb or #rrggbb or array of colors
  speed: 1.9, // Rounds per second
  trail: 40, // Afterglow percentage
  className: 'spinner', // The CSS class to assign to the spinner
};

// get positions of the t-sne plot before passing it to draw_tsne
//var target = document.getElementById("tsne");
var target = d3.select(".tsne").node();


//var update_tsne = function(data, kmer_list) {
function update_tsne(data, kmer_list) {
				
	
	//for(i=0; i<data.columns.length;i++){data.forEach(function(d){ d[data.columns[i]] = +d[data.columns[i]]; });}
	var dists = data.map(obj => Object.values(obj));
	tsne.initDataDist(dists);
	for(var k = 0; k < 250; k++) {
			tsne.step(); // every time you call this, solution gets better
	}
	var Y = tsne.getSolution(); 
	
	
	draw_tsne(Y, kmer_list)
	
}
</script>
</body>

</html>

